<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vku: Tutorial: Hello Triangle</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vku<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A set of Vulkan utilities based on RAII idiom and Modern C++ features.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial: Hello Triangle</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md8"></a></p>
<p>In this tutorial, we'll render a simple colored triangle without WSI (Window System Integration).</p>
<div class="image">
<img src="final.png" alt=""/>
<div class="caption">
Hello Triangle Screenshot</div></div>
    <dl class="section important"><dt>Important</dt><dd>For simpler setup, we'll use <code>VK_KHR_dynamic_rendering</code> device extension to skip the complex render pass and framebuffer preparation. Make sure your Vulkan driver supports the extension.</dd></dl>
<p>I'll explain each steps using Vulkan-Hpp RAII bindings first, then will explain which code can be replaced with <em>vku</em> provided. Note that this example has no WSI support yet, which will be covered in the next tutorial.</p>
<p>Here's the base code for the tutorial:</p>
<p><code>CMakeLists.txt</code> </p><div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.30)</div>
<div class="line"> </div>
<div class="line"># Set experimental flag to enable `import std` support from CMake.</div>
<div class="line">set(CMAKE_EXPERIMENTAL_CXX_IMPORT_STD &quot;0e5b6991-d74f-4b3d-a41c-cf096e0b2508&quot;)</div>
<div class="line"> </div>
<div class="line">project(vku-tutorial LANGUAGES CXX)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 23)</div>
<div class="line">set(CMAKE_CXX_MODULE_STD 1)</div>
<div class="line"> </div>
<div class="line"># ----------------</div>
<div class="line"># External dependencies.</div>
<div class="line"># ----------------</div>
<div class="line"> </div>
<div class="line">find_package(vku CONFIG REQUIRED)</div>
<div class="line"> </div>
<div class="line"># ----------------</div>
<div class="line"># Project executables.</div>
<div class="line"># ----------------</div>
<div class="line"> </div>
<div class="line">add_executable(vku-tutorial main.cpp)</div>
<div class="line">target_link_libraries(vku-tutorial PRIVATE vku::vku)</div>
</div><!-- fragment --><p><code>main.cpp</code> </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">import</span> std;</div>
<div class="line"><span class="keyword">import</span> <a class="code" href="module__vku.html">vku</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Code starts from here...</span></div>
<div class="line">}</div>
<div class="ttc" id="amodule__vku_html"><div class="ttname"><a href="module__vku.html">vku</a></div></div>
</div><!-- fragment --><p><code>vcpkg.json</code> </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;dependencies&quot;: [</div>
<div class="line">    &quot;vku&quot;</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
1. Creating Vulkan Instance</h1>
<p>To use the Vulkan API, an instance have to be created. Also, for Vulkan-Hpp's RAII binding, <code>vk::raii::Context</code> has to be created before the instance creation. We'll use Vulkan 1.0 to start from the scratch.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Context context;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">constexpr</span> vk::ApplicationInfo appInfo {</div>
<div class="line">        <span class="stringliteral">&quot;Hello Triangle&quot;</span>, <span class="comment">// pApplicationName </span></div>
<div class="line">        0, <span class="comment">// applicationVersion</span></div>
<div class="line">        <span class="keyword">nullptr</span>, <span class="comment">// pEngineName </span></div>
<div class="line">        0, <span class="comment">// engineVersion</span></div>
<div class="line">        vk::makeApiVersion(0, 1, 0, 0),</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">constexpr</span> std::array instanceLayers {</div>
<div class="line">        <span class="stringliteral">&quot;VK_LAYER_KHRONOS_validation&quot;</span>,</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Instance instance { context, vk::InstanceCreateInfo {</div>
<div class="line">        {}, <span class="comment">// flags</span></div>
<div class="line">        &amp;appInfo,</div>
<div class="line">        instanceLayers,</div>
<div class="line">    } };</div>
<div class="line">}</div>
</div><!-- fragment --><p>We created a Vulkan instance with application name <em>Hello Triangle</em>. I won't explain the detailed meaning of the structure fields, as it's already explained in the Vulkan specification. If you're not familiar with these, I suggest you to use raw Vulkan API first. This library assumes you're already familiar with Vulkan.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
1.1. <code>ErrorIncompatibleDriver</code> error on MoltenVK</h2>
<p>If you're in macOS and running Vulkan with <a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a> environment, you will likely get an error like this:</p>
<blockquote class="doxtable">
<p>&zwj;libc++abi: terminating due to uncaught exception of type vk::IncompatibleDriverError: Context::createInstance: ErrorIncompatibleDriver</p>
<p>Process finished with exit code 134 (interrupted by signal 6:SIGABRT) </p>
</blockquote>
<p>Since MoltenVK is portable implementation of Vulkan based on Apple Metal, you have to specify some additional parameters. Here's the modified code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Context context;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> vk::ApplicationInfo appInfo {</div>
<div class="line">        <span class="stringliteral">&quot;Hello Triangle&quot;</span>, 0,</div>
<div class="line">        <span class="keyword">nullptr</span>, 0,</div>
<div class="line">        vk::makeApiVersion(0, 1, 0, 0),</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">constexpr</span> std::array instanceLayers {</div>
<div class="line">        <span class="stringliteral">&quot;VK_LAYER_KHRONOS_validation&quot;</span>,</div>
<div class="line">    };</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">    <span class="keyword">constexpr</span> std::array instanceExtensions {</div>
<div class="line">        vk::KHRGetPhysicalDeviceProperties2ExtensionName,</div>
<div class="line">        vk::KHRPortabilityEnumerationExtensionName,</div>
<div class="line">    };</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    <span class="keyword">const</span> vk::raii::Instance instance { context, vk::InstanceCreateInfo {</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">        vk::InstanceCreateFlagBits::eEnumeratePortabilityKHR, <span class="comment">// flags</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">        {},</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        &amp;appInfo,</div>
<div class="line">        instanceLayers, <span class="comment">// pEnabledLayerNames</span></div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">        instanceExtensions, <span class="comment">// pEnabledExtensionNames</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    } };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now running your application will create a Vulkan instance and return 0.</p>
<hr  />
<p>Let's talk about the current code's refactoring point. You may notice that you cannot "inline" the parameters into <code>vk::InstanceCreateInfo</code> directly, like</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> vk::raii::Instance { context, vk::InstanceCreateInfo {</div>
<div class="line">    {},</div>
<div class="line">    &amp;vk::ApplicationInfo { ... }, <span class="comment">// &lt;- Can&#39;t take the address of a rvalue.</span></div>
<div class="line">    { ... }, <span class="comment">// &lt;- vk::ArrayProxyNoTemporaries doesn&#39;t allow the construction from a rvalue.</span></div>
<div class="line">    { ... }, <span class="comment">// same as above.</span></div>
<div class="line">} };</div>
</div><!-- fragment --><p>Because Vulkan-Hpp disallows <code>vk::ArrayProxyNoTemporaries</code> construction from any rvalue. Since Vulkan structure is constructed for the future function calling parameter, its referencing data must be alive until the function calling end. The following code shows why allowing it is dangerous:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> vk::InstanceCreateInfo ci { </div>
<div class="line">    ...,</div>
<div class="line">    { extension1, extension2, ... },</div>
<div class="line">}; <span class="comment">// std::initializer_list of the extensions is destroyed at here.</span></div>
<div class="line"><span class="keyword">const</span> vk::raii::Instance instance { context, ci }; <span class="comment">// ci refers the dangling.</span></div>
</div><!-- fragment --><p>However, back to the first code, is perfectly valid from the aspect of the object lifetime. Since <code>vk::ApplicationInfo</code> struct and instance extensions <code>initializer_list</code> are destroyed at the end of the expression, they will be alive while the function calling.</p>
<p>Anyway, Vulkan-Hpp chooses the safe side, and due to this decision we got several disadvantages:</p>
<ul>
<li>We have to name some trivial structs that are only used for the function calling. Naming things are hard!</li>
<li>The flow of the code is reversed from the natural order of reading. If we want to know what parameters have been passed to the function calling, we have to find these parameter variables, which are declared before the function calling. If structures are nested (such like <code>vk::GraphicsPipelineCreateInfo</code> or <code>vk::RenderPassCreateInfo</code>), it's much harder to understand the code.</li>
</ul>
<p>For solution, <em>vku</em> provides the two functions, <code>vku::unsafeAddress(const T&amp;)</code> and <code>vku::unsafeProxy(const &lt;contiguous-range&gt;&amp;)</code>.</p>
<ul>
<li><code>unsafeAddress</code> accepts a const-qualified value and return its address. The returned value is valid until the expression end.</li>
<li><code>unsafeProxy</code> accepts a const-qualified lvalue of a contiguous range (<code>std::array</code>, <code>std::vector</code>, <code>std::initializer_list</code>, ...) or a value and return <code>vk::ArrayProxyNoTemporaries</code> that can be used in Vulkan-Hpp. The returned proxy object is valid until the expression end.</li>
</ul>
<p>With these functions, you can write the code like this:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> vk::raii::Context context;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> vk::raii::Instance instance { context, vk::InstanceCreateInfo {</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">    vk::InstanceCreateFlagBits::eEnumeratePortabilityKHR,</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">    {},</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    vku::unsafeAddress(vk::ApplicationInfo {</div>
<div class="line">        <span class="stringliteral">&quot;Hello Triangle&quot;</span>, 0,</div>
<div class="line">        <span class="keyword">nullptr</span>, 0,</div>
<div class="line">        vk::makeApiVersion(0, 1, 0, 0),</div>
<div class="line">    }),</div>
<div class="line">    vku::unsafeProxy&lt;const char*&gt;(<span class="stringliteral">&quot;VK_LAYER_KHRONOS_validation&quot;</span>), <span class="comment">// Specified the template type, unless it will be deduced as char array.</span></div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">    vku::unsafeProxy({</div>
<div class="line">        vk::KHRGetPhysicalDeviceProperties2ExtensionName,</div>
<div class="line">        vk::KHRPortabilityEnumerationExtensionName,</div>
<div class="line">    }),</div>
<div class="line">#endif</div>
<div class="line">} };</div>
</div><!-- fragment --><p>Which got much clearer, and unnecessary variable naming is gone.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
2. Creating a Vulkan Device with a Graphics Capable Queue</h1>
<p>For this step, we'll get the physical device from <code>instance</code>, and create a device with graphics queue. First, we have to check if there is a graphics operation cable physical device.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ... </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Instance instance { ... };</div>
<div class="line">    </div>
<div class="line">    std::uint32_t graphicsQueueFamilyIndex;</div>
<div class="line">    <span class="keyword">const</span> vk::raii::PhysicalDevice physicalDevice = [&amp;] {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> vk::raii::PhysicalDevice &amp;physicalDevice : instance.enumeratePhysicalDevices()) {</div>
<div class="line">            <span class="keywordflow">for</span> (std::uint32_t queueFamilyIndex = 0; vk::QueueFamilyProperties properties : physicalDevice.getQueueFamilyProperties()) {</div>
<div class="line">                <span class="keywordflow">if</span> (properties.queueFlags &amp; vk::QueueFlagBits::eGraphics) {</div>
<div class="line">                    graphicsQueueFamilyIndex = queueFamilyIndex;</div>
<div class="line">                    <span class="keywordflow">return</span> physicalDevice;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                ++queueFamilyIndex;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error { <span class="stringliteral">&quot;No graphics operation supporting GPU.&quot;</span> };</div>
<div class="line">    }();</div>
<div class="line">}</div>
</div><!-- fragment --><p>For this tutorial, we only queried about the graphics queue family support for brevity, but this process is widely varying on the application's purpose, such like:</p>
<ul>
<li>Need dedicated compute/transfer queue.</li>
<li>Need to check the surface support for WSI.</li>
<li>Need to check some GPU specific feature support.</li>
<li>Selecting the "best" GPU with the above requirements.</li>
</ul>
<p>I'll cover how these goal can be achieved with <em>vku</em> in the next tutorials.</p>
<p>Next, creating a device with the graphics queue:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">const</span> vk::raii::PhysicalDevice physicalDevice { ... };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Device device { physicalDevice, vk::DeviceCreateInfo {</div>
<div class="line">        {}, <span class="comment">// flags</span></div>
<div class="line">        vku::unsafeProxy(vk::DeviceQueueCreateInfo { </div>
<div class="line">             {}, <span class="comment">// flags </span></div>
<div class="line">             graphicsQueueFamilyIndex, </div>
<div class="line">             vku::unsafeProxy(1.f), <span class="comment">// queuePriorities</span></div>
<div class="line">        }), <span class="comment">// queueCreateInfos</span></div>
<div class="line">        {}, <span class="comment">// pEnabledLayerNames</span></div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">        vku::unsafeProxy(vk::KHRPortabilitySubsetExtensionName), <span class="comment">// pEnabledExtensionNames</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    } };</div>
<div class="line">    <span class="keyword">const</span> vk::Queue graphicsQueue = (*device).getQueue(graphicsQueueFamilyIndex, <span class="comment">/* queueIndex */</span> 0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>We created the graphics capable queue with priority <code>1.0</code> (full priority).</p>
<hr  />
<p>Wow, we've done a lot of things! The amount of code is not much unbearable, but it's quite verbose and troublesome. Let's see how <em>vku</em> can help you with this.</p>
<p><em>vku</em> provides <code>Gpu&lt;QueueFamilies, Queues&gt;</code> class for convenient and structured physical device selection and device creation. Here's the same featuring code with <em>vku</em>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">struct </span>QueueFamilies {</div>
<div class="line">    std::uint32_t graphics;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> QueueFamilies(vk::PhysicalDevice physicalDevice)</div>
<div class="line">        : graphics { vku::getGraphicsQueueFamily(physicalDevice.getQueueFamilyProperties()).value() } { }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Queues {</div>
<div class="line">    vk::Queue graphics;</div>
<div class="line"> </div>
<div class="line">    Queues(vk::Device device, <span class="keyword">const</span> QueueFamilies &amp;queueFamilies)</div>
<div class="line">        : graphics { device.getQueue(queueFamilies.graphics, 0) } { }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">auto</span> getCreateInfos(vk::PhysicalDevice, <span class="keyword">const</span> QueueFamilies &amp;queueFamilies) <span class="keyword">noexcept</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="classvku_1_1RefHolder.html">vku::RefHolder</a> {</div>
<div class="line">            [=](<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;priority) {</div>
<div class="line">                <span class="keywordflow">return</span> vk::DeviceQueueCreateInfo {</div>
<div class="line">                    {},</div>
<div class="line">                    queueFamilies.graphics,</div>
<div class="line">                    vk::ArrayProxyNoTemporaries(priority),</div>
<div class="line">                };</div>
<div class="line">            },</div>
<div class="line">            1.f,</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Instance instance { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Note: vku::Gpu&lt;QueueFamilies, Queues&gt;::Config can be omitted. I&#39;ll leave it for the demonstration.</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1Gpu.html">vku::Gpu&lt;QueueFamilies, Queues&gt;</a> gpu { instance, <a class="code hl_struct" href="structvku_1_1Gpu_1_1Config.html">vku::Gpu&lt;QueueFamilies, Queues&gt;::Config</a> {</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">         .deviceExtensions = {</div>
<div class="line">             vk::KHRPortabilitySubsetExtensionName,</div>
<div class="line">         },</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    } };</div>
<div class="line">    <span class="comment">// gpu.physicalDevice (vk::raii::PhysicalDevice)</span></div>
<div class="line">    <span class="comment">// gpu.queueFamilies (QueueFamilies)</span></div>
<div class="line">    <span class="comment">// gpu.device (vk::raii::Device)</span></div>
<div class="line">    <span class="comment">// gpu.queues (Queues)</span></div>
<div class="line">    <span class="comment">// gpu.allocator (vma::Allocator)</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassvku_1_1Gpu_html"><div class="ttname"><a href="classvku_1_1Gpu.html">vku::Gpu</a></div><div class="ttdoc">Bootstrapper for Vulkan RAII physical device, device, allocator creation.</div><div class="ttdef"><b>Definition</b> Gpu.cppm:35</div></div>
<div class="ttc" id="aclassvku_1_1RefHolder_html"><div class="ttname"><a href="classvku_1_1RefHolder.html">vku::RefHolder</a></div><div class="ttdoc">A container type that can be contextually converted to a reference of type T, which has references fo...</div><div class="ttdef"><b>Definition</b> RefHolder.cppm:20</div></div>
<div class="ttc" id="astructvku_1_1Gpu_1_1Config_html"><div class="ttname"><a href="structvku_1_1Gpu_1_1Config.html">vku::Gpu::Config</a></div><div class="ttdef"><b>Definition</b> Gpu.cppm:188</div></div>
</div><!-- fragment --><p>All codes were gone! Parameters for physical device selection and device creation are in the <code><a class="el" href="classvku_1_1Gpu.html" title="Bootstrapper for Vulkan RAII physical device, device, allocator creation.">vku::Gpu</a>&lt;QueueFamilies, Queues&gt;::Config</code> struct, and initialized for typical usage. If you want, the settings can be modified using constructor. This struct has many parameters for sophisticated, fine-grained physical device selection, but I'll leave that details for later.</p>
<p>Here's the explanation of the code:</p>
<ol type="1">
<li>The process is done in the same order of our previous Vulkan-Hpp based code. It enumerates the physical devices and "check" some availability of them, with following criteria:<ul>
<li>Queue family requirements: for each physical device, <em>vku</em> tried to construct the given <code>QueueFamilies</code> struct with it. If error thrown, skip it from the candidates.</li>
<li>Device extensions requirements: check if the required extensions are supported. If not, skip it from the candidates.</li>
<li>Physical device features requirements: check if the required physical device features (<code>vk::PhysicalDeviceFeatures</code>) are supported. If not, skip it from the candidates.</li>
<li>For remaining physical devices candidates, they are rated by their properties, which has the same rule of <a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families#page_Base-device-suitability-checks">vulkan-tutorial</a>'s. The best scored physical device is selected.</li>
</ul>
</li>
<li>After the physical device selection, <code>QueueFamilies</code> struct is constructed with the selected physical device. <code>vku::getGraphicsQueueFamily</code> is a helper function that accepts a physical device's queue family properties and returns the queue family index that supports the graphics operation. If there's no such queue family, it returns <code>std::nullopt</code>.</li>
<li>After that, device is created with <code>Config</code>'s device extensions and queue create infos provided by <code>Queues::getCreateInfos</code>. This function <b>MUST</b> be implemented by the user, and meets the following requirements:<ul>
<li>It's signature must be <code>getCreateInfos(vk::PhysicalDevice, const QueueFamilies&amp;)</code> and be static.</li>
<li>It must return <code><a class="el" href="classvku_1_1RefHolder.html" title="A container type that can be contextually converted to a reference of type T, which has references fo...">vku::RefHolder</a></code> of <b>either a single <code>vk::DeviceQueueCreateInfo</code> struct</b> or <b>contiguous <code>vk::DeviceQueueCreateInfo</code> container</b>. <code><a class="el" href="classvku_1_1RefHolder.html" title="A container type that can be contextually converted to a reference of type T, which has references fo...">vku::RefHolder</a>&lt;T, Args...&gt;</code> is a utility class, a container that can be contextually converted to a reference of type <code>T</code>, which has references for objects of <code>Args...</code>. In this code, since the returning <code>vk::DeviceQueueCreateInfo</code> needs the reference of queue priority value, it is wrapped with <code><a class="el" href="classvku_1_1RefHolder.html" title="A container type that can be contextually converted to a reference of type T, which has references fo...">vku::RefHolder</a></code>.</li>
</ul>
</li>
<li>After the device creation, the queues are gotten by constructing <code>Queues</code> with the device and queue families. This is implemented by user side.</li>
<li>Finally, it creates <code>vma::Allocator</code>, which will be used as resource allocator such like buffer and image.</li>
</ol>
<p>If you pass <code>verbose</code> boolean field as <code>true</code> to the <code>Gpu</code> constructor, physical device selection process (including rejection reason and score of the accepted physical device) is printed to <code>std::cerr</code>.</p>
<details >
<summary >
Example</summary>
<p>For example, the following (more sophisticated GPU selection) code</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">   <a class="code hl_class" href="classvku_1_1Gpu.html">vku::Gpu&lt;QueueFamilies, Queues&gt;</a> gpu { instance, <a class="code hl_struct" href="structvku_1_1Gpu_1_1Config.html">vku::Gpu&lt;QueueFamilies, Queues&gt;::Config</a> {</div>
<div class="line">       .verbose = <span class="keyword">true</span>,</div>
<div class="line">       .deviceExtensions = {</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">           vk::KHRPortabilitySubsetExtensionName,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">           vk::KHRMaintenance4ExtensionName,</div>
<div class="line">           vk::EXTDescriptorBufferExtensionName,</div>
<div class="line">           vk::KHRDynamicRenderingLocalReadExtensionName,</div>
<div class="line">       },</div>
<div class="line">       .physicalDeviceFeatures = vk::PhysicalDeviceFeatures{}</div>
<div class="line">           .setGeometryShader(<span class="keyword">true</span>)</div>
<div class="line">           .setIndependentBlend(<span class="keyword">true</span>),</div>
<div class="line">       .devicePNexts = std::tuple {</div>
<div class="line">           vk::PhysicalDeviceDescriptorBufferFeaturesEXT{}</div>
<div class="line">               .setDescriptorBuffer(<span class="keyword">true</span>)</div>
<div class="line">               .setDescriptorBufferCaptureReplay(<span class="keyword">true</span>),</div>
<div class="line">           vk::PhysicalDeviceDynamicRenderingLocalReadFeaturesKHR{}</div>
<div class="line">               .setDynamicRenderingLocalRead(<span class="keyword">true</span>),</div>
<div class="line">       },</div>
<div class="line">       .apiVersion = vk::makeApiVersion(0, 1, 3, 0),</div>
<div class="line">   } };</div>
</div><!-- fragment --><p>The possible output is:</p>
<blockquote class="doxtable">
<p>&zwj;Physical device "Intel UHD Graphics 4000" rejected because it lacks the following device extensions: [VK_KHR_dynamic_rendering_local_read, VK_KHR_maintenance4]</p>
<p>Physical device "NVIDIA MX 150" rejected because it lacks the following physical device features: [geometryShader]</p>
<p>Physical device "NVIDIA RTX 2080" accepted (score=16384). </p>
</blockquote>
</details>
<p>Like many other <em>vku</em> objects, <code><a class="el" href="classvku_1_1Gpu.html" title="Bootstrapper for Vulkan RAII physical device, device, allocator creation.">vku::Gpu</a></code> follows the RAII convention, and it automatically destroys the created device and allocator when it is destroyed.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
3. Creating the Image to Be Rendered</h1>
<p>Now, we're going create the 512x512 image that will be used for the rendering attachment. For this step, I'll just briefly explain how the conventional Vulkan-Hpp code does, because it is too complex to be in this tutorial. It would be:</p>
<ol type="1">
<li>Create <code>vk::raii::Image</code> object (let it <code>image</code>) with <code>gpu.device</code> and <code>vk::ImageCreateInfo</code> struct.</li>
<li>Create <code>vk::raii::DeviceMemory</code> object with <code>gpu.device</code> and <code>image</code>'s allocation size, memory alignment, and memory properties for color attachment usage.</li>
<li>Bind the <code>image</code> to the device memory.</li>
</ol>
<p>which involves a lot of headache steps.</p>
<hr  />
<p>As explained in above, <em>vku</em> uses <a href="https://gpuopen.com/vulkan-memory-allocator/">Vulkan Memory Allocator (VMA)</a> for primary memory management. VMA is a library that provides a simple and efficient way to manage the Vulkan memory allocation, and it's widely used in the Vulkan industry. <em>vku</em> uses the Vulkan-Hpp version of VMA, <a href="https://github.com/YaaZ/VulkanMemoryAllocator-Hpp">VulkanMemoryAllocator-Hpp</a>, by YaaZ.</p>
<p>The main allocator object, <code>vma::Allocator</code>, is inside <code><a class="el" href="classvku_1_1Gpu.html" title="Bootstrapper for Vulkan RAII physical device, device, allocator creation.">vku::Gpu</a></code> class as the public field. With this, your image generation get much simpler:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ... </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1Gpu.html">vku::Gpu&lt;QueueFamilies, Queues&gt;</a> gpu { ... };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { gpu.allocator, vk::ImageCreateInfo {</div>
<div class="line">        {},</div>
<div class="line">        vk::ImageType::e2D,</div>
<div class="line">        vk::Format::eR8G8B8A8Unorm,</div>
<div class="line">        vk::Extent3D { 512, 512, 1 },</div>
<div class="line">        1, <span class="comment">// mipLevels</span></div>
<div class="line">        1, <span class="comment">// arrayLayers</span></div>
<div class="line">        vk::SampleCountFlagBits::e1, <span class="comment">// samples</span></div>
<div class="line">        vk::ImageTiling::eOptimal,</div>
<div class="line">        vk::ImageUsageFlagBits::eColorAttachment,</div>
<div class="line">    } };</div>
<div class="line">}</div>
<div class="ttc" id="astructvku_1_1AllocatedImage_html"><div class="ttname"><a href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a></div><div class="ttdoc">Owning image handle with memory allocation.</div><div class="ttdef"><b>Definition</b> AllocatedImage.cppm:23</div></div>
</div><!-- fragment --><p><code><a class="el" href="structvku_1_1AllocatedImage.html" title="Owning image handle with memory allocation.">vku::AllocatedImage</a></code> is an object that owns <code>vk::Image</code> and <code>vma::Allocation</code> objects. It follows the RAII convention, and automatically destroys them when it is destroyed. It can be constructed by</p>
<ul>
<li><code>vma::Allocator</code> (used by GPU resource allocation)</li>
<li><code>vk::ImageCreateInfo</code> (for image creation),</li>
<li>and optional <code>vma::AllocationCreateInfo</code> (allocation creation property, detailed explanation is in <a href="https://gpuopen-librariesandsdks.github.io/VulkanMemoryAllocator/html/choosing_memory_type.html">VMA documentation</a>) which is defaulted by no flags and memory usage with device preferred (<code>vma::AllocationCreateInfo { {}, vma::MemoryUsage::eAutoPreferDevice }</code>)</li>
</ul>
<p><code><a class="el" href="structvku_1_1AllocatedImage.html" title="Owning image handle with memory allocation.">vku::AllocatedImage</a></code> inherits its base class <code><a class="el" href="structvku_1_1Image.html" title="Non-owning vk::Image handle with the additional information.">vku::Image</a></code>, which is a non-owning object that have <code>vk::Image</code> handle and its properties (extent, format, mip levels and array layers) that were used at the initialization.</p>
<div class="image">
<img src="vku-image-hierarchy.png" alt=""/>
<div class="caption">
Hierarchy of vku::Image and vku::AllocatedImage</div></div>
    <p>Due to this inheritance, you can take three advantages:</p>
<ol type="1">
<li><code><a class="el" href="structvku_1_1Image.html" title="Non-owning vk::Image handle with the additional information.">vku::Image</a></code> objects can be contextually converted into <code>vk::Image</code> and so <code><a class="el" href="structvku_1_1AllocatedImage.html" title="Owning image handle with memory allocation.">vku::AllocatedImage</a></code>. Therefore, you can use them as <code>vk::Image</code> objects without any explicit conversion.</li>
<li>You can access to some frequently used image properties (listed in above) after image creation.</li>
<li><code><a class="el" href="structvku_1_1Image.html" title="Non-owning vk::Image handle with the additional information.">vku::Image</a></code> can be constructed with raw <code>vk::Image</code> with designated initializer, which makes your existing codebase adopting to <em>vku</em> easier.</li>
</ol>
<h2><a class="anchor" id="autotoc_md16"></a>
3.1. Creating the Image View</h2>
<p>After the image creation, we have to create the image view for it.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::ImageView imageView { gpu.device, vk::ImageViewCreateInfo { </div>
<div class="line">        {}, <span class="comment">// flags</span></div>
<div class="line">        image,</div>
<div class="line">        vk::ImageViewType::e2D,</div>
<div class="line">        vk::Format::eR8G8B8A8Unorm,</div>
<div class="line">        {}, <span class="comment">// componentMapping</span></div>
<div class="line">        vk::ImageSubresourceRange {</div>
<div class="line">            vk::ImageAspectFlagBits::eColor,</div>
<div class="line">            0, <span class="comment">// baseMipLevel</span></div>
<div class="line">            1, <span class="comment">// levelCount</span></div>
<div class="line">            0, <span class="comment">// baseArrayLayer</span></div>
<div class="line">            1, <span class="comment">// layerCount</span></div>
<div class="line">        }, <span class="comment">// subresourceRange</span></div>
<div class="line">    } };</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can see <code>image</code> is implicitly converted to <code>vk::Image</code>.</p>
<p>Since <code><a class="el" href="structvku_1_1Image.html" title="Non-owning vk::Image handle with the additional information.">vku::Image</a></code> has much more information than <code>vk::Image</code> (in this case, it knows its format), it has <code>getViewCreateInfo</code> method, which uses the format and inferred aspect flags from the format. Regarding this, the code can be:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::ImageView imageView { gpu.device, image.getViewCreateInfo() };</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>getViewCreateInfo</code> method has two overloads:</p>
<ul>
<li><code>getViewCreateInfo(vk::ImageViewType type = vk::ImageViewType::e2D) -&gt; vk::ImageViewCreateInfo</code> It creates the <code>vk::ImageViewCreateInfo</code> with given image view type (default is <code>vk::ImageViewType::e2D</code>), with full subresource range (all mip levels and array layers) and inferred aspect flags.</li>
<li><code>getViewCreateInfo(const vk::ImageSubresourceRange &amp;subresourceRange, vk::ImageViewType type = vk::ImageViewType::e2D) -&gt; vk::ImageViewCreateInfo</code> It creates the <code>vk::ImageViewCreateInfo</code> with given image view type and subresource range. If you need the specific subresource range, you can use this overload.</li>
</ul>
<p>Both functions use identity component mapping.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
4. Creating the Graphics Pipeline</h1>
<p>To create a graphics pipeline, we have to:</p><ol type="1">
<li>Create a pipeline layout.</li>
<li>Create shader modules from SPIR-V binaries.</li>
<li>Create a graphics pipeline using pipeline layout and shader modules.</li>
</ol>
<p>Pipeline layout creation is easy: we don't have any descriptor set layout or push constant now, therefore just passing a default <code>vk::PipelineLayoutCreateInfo</code> is enough.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">const</span> vk::raii::ImageView imageView { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::PipelineLayout pipelineLayout { gpu.device, vk::PipelineLayoutCreateInfo{} };</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
4.1. Shader module creation</h2>
<p>For this step, we have to write the shader code. Here's the shader code:</p>
<p><code>shaders/triangle.vert</code> </p><div class="fragment"><div class="line">#version 460</div>
<div class="line"> </div>
<div class="line">const vec2 positions[] = {</div>
<div class="line">    { -0.5,  0.5 },</div>
<div class="line">    {  0.5,  0.5 },</div>
<div class="line">    {  0.0, -0.5 },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const vec3 colors[] = {</div>
<div class="line">    { 1.0, 0.0, 0.0 },</div>
<div class="line">    { 0.0, 1.0, 0.0 },</div>
<div class="line">    { 0.0, 0.0, 1.0 },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">layout (location = 0) out vec3 fragColor;</div>
<div class="line"> </div>
<div class="line">void main(){</div>
<div class="line">    fragColor = colors[gl_VertexIndex];</div>
<div class="line">    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We used the GLSL's <a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Initializer_lists">initializer list-based initialization</a>, which is supported from GLSL 4.6.</dd></dl>
<p><code>shaders/triangle.frag</code> </p><div class="fragment"><div class="line">#version 450</div>
<div class="line"> </div>
<div class="line">layout (location = 0) in vec3 fragColor;</div>
<div class="line"> </div>
<div class="line">layout (location = 0) out vec4 outColor;</div>
<div class="line"> </div>
<div class="line">void main(){</div>
<div class="line">   outColor = vec4(fragColor, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After the shader writing, you can compile them into SPIR-V binary by executing the following command:</p>
<div class="fragment"><div class="line">glslc triangle.vert -o triangle.vert.spv</div>
<div class="line">glslc triangle.frag -o triangle.frag.spv</div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>You don't have to specify the shader type, since their extension is <code>vert</code> and <code>frag</code>, which is known as the vertex and fragment shader. <code>glslc</code> can automatically infer the shader stage from an extension.</dd></dl>
<p>Back to the C++ side, you have to load the SPIR-V binary and create <code>vk::raii::ShaderModule</code> for each stage. I'll first define the macro variable <code>COMPILED_SHADER_DIR</code> for the shader directory path to prevent some relative path issue.</p>
<p><code>CMakeLists.txt</code> </p><div class="fragment"><div class="line">...</div>
<div class="line">target_link_libraries(vku-tutorial PRIVATE vku::vku)</div>
<div class="line">target_compile_definitions(vku-tutorial PRIVATE</div>
<div class="line">    COMPILED_SHADER_DIR=&quot;${CMAKE_CURRENT_SOURCE_DIR}/shaders&quot;</div>
<div class="line">)</div>
</div><!-- fragment --><p><code>main.cpp</code> </p><div class="fragment"><div class="line"> ++</div>
<div class="line">[[nodiscard]] <span class="keyword">auto</span> loadFileAsBinary(<span class="keyword">const</span> std::filesystem::path &amp;path) -&gt; std::vector&lt;std::uint32_t&gt; {</div>
<div class="line">    std::ifstream file { path, std::ios::binary };</div>
<div class="line">    <span class="keywordflow">if</span> (!file) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error { <span class="stringliteral">&quot;Failed to open file!&quot;</span> };</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    file.seekg(0, std::ios::end);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> fileSize = file.tellg();</div>
<div class="line">    file.seekg(0, std::ios::beg);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::uint32_t&gt; result(fileSize / <span class="keyword">sizeof</span>(std::uint32_t));</div>
<div class="line">    file.read(<span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(result.data()), fileSize);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ...</div>
<div class="line">    <span class="keyword">const</span> vk::raii::PipelineLayout pipelineLayout { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::ShaderModule vertexShaderModule { gpu.device, vk::ShaderModuleCreateInfo {</div>
<div class="line">        {}, <span class="comment">// flags</span></div>
<div class="line">        vku::unsafeProxy(loadFileAsBinary(COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.vert.spv&quot;</span>)),</div>
<div class="line">    } };</div>
<div class="line">    <span class="keyword">const</span> vk::raii::ShaderModule fragmentShaderModule { gpu.device, vk::ShaderModuleCreateInfo {</div>
<div class="line">        {},</div>
<div class="line">        vku::unsafeProxy(loadFileAsBinary(COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.frag.spv&quot;</span>)),</div>
<div class="line">    } };</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
4.2. Creating the Graphics Pipeline</h2>
<p>Finally, the most cumbersome part of the Vulkan API, creating the graphics pipeline. Here's the code by using Vulkan-Hpp naively:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::ShaderModule vertexShaderModule { ... };</div>
<div class="line">    <span class="keyword">const</span> vk::raii::ShaderModule fragmentShaderModule { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Pipeline pipeline { gpu.device, <span class="keyword">nullptr</span>, vk::StructureChain {</div>
<div class="line">        vk::GraphicsPipelineCreateInfo {</div>
<div class="line">            {}, <span class="comment">// flags</span></div>
<div class="line">            vku::unsafeProxy({</div>
<div class="line">                vk::PipelineShaderStageCreateInfo { </div>
<div class="line">                    {}, <span class="comment">// flags</span></div>
<div class="line">                    vk::ShaderStageFlagBits::eVertex,</div>
<div class="line">                    *vertexShaderModule, </div>
<div class="line">                    <span class="stringliteral">&quot;main&quot;</span>, <span class="comment">// pName</span></div>
<div class="line">                },</div>
<div class="line">                vk::PipelineShaderStageCreateInfo { </div>
<div class="line">                    {}, <span class="comment">// flags</span></div>
<div class="line">                    vk::ShaderStageFlagBits::eFragment,</div>
<div class="line">                    *fragmentShaderModule, </div>
<div class="line">                    <span class="stringliteral">&quot;main&quot;</span>, <span class="comment">// pName</span></div>
<div class="line">                },</div>
<div class="line">            }), <span class="comment">// stages</span></div>
<div class="line">            vku::unsafeAddress(vk::PipelineVertexInputStateCreateInfo{}), <span class="comment">// pVertexInputState</span></div>
<div class="line">            vku::unsafeAddress(vk::PipelineInputAssemblyStateCreateInfo {</div>
<div class="line">                {}, <span class="comment">// flags</span></div>
<div class="line">                vk::PrimitiveTopology::eTriangleList,</div>
<div class="line">            }), <span class="comment">// pInputAssemblyState</span></div>
<div class="line">            {}, <span class="comment">// pTessellationState</span></div>
<div class="line">            vku::unsafeAddress(vk::PipelineViewportStateCreateInfo {</div>
<div class="line">                {}, <span class="comment">// flags</span></div>
<div class="line">                vku::unsafeProxy(vku::toViewport(vku::toExtent2D(image.extent))), <span class="comment">// viewports</span></div>
<div class="line">                vku::unsafeProxy(vk::Rect2D { { 0, 0 }, vku::toExtent2D(image.extent) }), <span class="comment">// scissors</span></div>
<div class="line">            }), <span class="comment">// pViewportState</span></div>
<div class="line">            vku::unsafeAddress(vk::PipelineRasterizationStateCreateInfo {</div>
<div class="line">                {}, <span class="comment">// flags</span></div>
<div class="line">                <span class="keyword">false</span>, <span class="comment">// depthClampEnable</span></div>
<div class="line">                <span class="keyword">false</span>, <span class="comment">// rasterizerDiscardEnable</span></div>
<div class="line">                vk::PolygonMode::eFill,</div>
<div class="line">                vk::CullModeFlagBits::eNone, </div>
<div class="line">                {}, <span class="comment">// frontFace</span></div>
<div class="line">                {}, <span class="comment">// depthBiasEnable</span></div>
<div class="line">                {}, <span class="comment">// depthBiasConstantFactor</span></div>
<div class="line">                {}, <span class="comment">// depthBiasClamp</span></div>
<div class="line">                {}, <span class="comment">// depthBiasSlopeFactor</span></div>
<div class="line">                1.f, <span class="comment">// lineWidth</span></div>
<div class="line">            }), <span class="comment">// pRasterizationState</span></div>
<div class="line">            vku::unsafeAddress(vk::PipelineMultisampleStateCreateInfo {</div>
<div class="line">                {}, <span class="comment">// flags</span></div>
<div class="line">                vk::SampleCountFlagBits::e1, <span class="comment">// rasterizationSamples</span></div>
<div class="line">            }), <span class="comment">// pMultisampleState</span></div>
<div class="line">            {}, <span class="comment">// pDepthStencilState</span></div>
<div class="line">            vku::unsafeAddress(vk::PipelineColorBlendStateCreateInfo {</div>
<div class="line">                {}, <span class="comment">// flags</span></div>
<div class="line">                <span class="keyword">false</span>, <span class="comment">// logicOpEnable </span></div>
<div class="line">                {}, <span class="comment">// logicOp</span></div>
<div class="line">                vku::unsafeProxy(vk::PipelineColorBlendAttachmentState {</div>
<div class="line">                    <span class="keyword">false</span>, <span class="comment">// blendEnable</span></div>
<div class="line">                    {}, {}, {}, <span class="comment">// srcColorBlendFactor, dstColorBlendFactor, colorBlendOp</span></div>
<div class="line">                    {}, {}, {}, <span class="comment">// srcAlphaBlendFactor, dstAlphaBlendFactor, alphaBlendOp</span></div>
<div class="line">                    vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA, <span class="comment">// colorWriteMask</span></div>
<div class="line">                }), <span class="comment">// attachments</span></div>
<div class="line">            }),</div>
<div class="line">            vku::unsafeAddress(vk::PipelineDynamicStateCreateInfo{}), <span class="comment">// pDynamicState</span></div>
<div class="line">            *pipelineLayout,</div>
<div class="line">        },</div>
<div class="line">        vk::PipelineRenderingCreateInfo {</div>
<div class="line">            {}, <span class="comment">// viewMask</span></div>
<div class="line">            image.format, <span class="comment">// colorAttachementFormats</span></div>
<div class="line">        },</div>
<div class="line">    }.get() };</div>
<div class="line">}</div>
</div><!-- fragment --><p>Since the extent of the rendering attachment is known (512x512) and fixed, we embedded the viewport and scissor into the pipeline creation. (For most case, you'll use the dynamic state for it!) Also, we used Vulkan-Hpp provided <code>vk::StructureChain</code>, which concatenates the Vulkan structure objects' pNext chain.</p>
<details >
<summary >
I think it is worth to show what if we don't use <code>vku::unsafeProxy</code> and <code>vku::unsafeAddress</code>.</summary>
<p></p>
<div class="fragment"><div class="line">++</div>
<div class="line">  <span class="keywordtype">int</span> main() {</div>
<div class="line">      <span class="keyword">const</span> std::array stages {</div>
<div class="line">          vk::PipelineShaderStageCreateInfo {</div>
<div class="line">              {},</div>
<div class="line">              vk::ShaderStageFlagBits::eVertex,</div>
<div class="line">              *vertexShaderModule,</div>
<div class="line">              <span class="stringliteral">&quot;main&quot;</span>,</div>
<div class="line">          },</div>
<div class="line">          vk::PipelineShaderStageCreateInfo {</div>
<div class="line">              {},</div>
<div class="line">              vk::ShaderStageFlagBits::eFragment,</div>
<div class="line">              *fragmentShaderModule,</div>
<div class="line">              <span class="stringliteral">&quot;main&quot;</span>,</div>
<div class="line">          },</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">constexpr</span> vk::PipelineVertexInputStateCreateInfo vertexInputState{};</div>
<div class="line">      <span class="keyword">constexpr</span> vk::PipelineInputAssemblyStateCreateInfo inputAssemblyState {</div>
<div class="line">          {},</div>
<div class="line">          vk::PrimitiveTopology::eTriangleList,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">const</span> vk::Viewport viewport {</div>
<div class="line">          0.f,</div>
<div class="line">          0.f,</div>
<div class="line">          <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(image.extent.width),</div>
<div class="line">          <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(image.extent.height),</div>
<div class="line">          0.f,</div>
<div class="line">          1.f,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">const</span> vk::Rect2D scissor {</div>
<div class="line">          { 0, 0 },</div>
<div class="line">          { image.extent.width, image.extent.height },</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">const</span> vk::PipelineViewportStateCreateInfo viewportState {</div>
<div class="line">          {},</div>
<div class="line">          viewport,</div>
<div class="line">          scissor,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">constexpr</span> vk::PipelineRasterizationStateCreateInfo rasterizationState {</div>
<div class="line">          {},</div>
<div class="line">          <span class="keyword">false</span>,</div>
<div class="line">          <span class="keyword">false</span>,</div>
<div class="line">          vk::PolygonMode::eFill,</div>
<div class="line">          vk::CullModeFlagBits::eNone,</div>
<div class="line">          {},</div>
<div class="line">          {}, </div>
<div class="line">          {},</div>
<div class="line">          {},</div>
<div class="line">          {},</div>
<div class="line">          1.f,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">constexpr</span> vk::PipelineMultisampleStateCreateInfo multisampleState {</div>
<div class="line">          {},</div>
<div class="line">          vk::SampleCountFlagBits::e1,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">constexpr</span> vk::PipelineColorBlendAttachmentState colorBlendAttachmentState {</div>
<div class="line">          <span class="keyword">false</span>,</div>
<div class="line">          {}, {}, {},</div>
<div class="line">          {}, {}, {},</div>
<div class="line">          vk::ColorComponentFlagBits::eR | vk::ColorComponentFlagBits::eG | vk::ColorComponentFlagBits::eB | vk::ColorComponentFlagBits::eA,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">const</span> vk::PipelineColorBlendStateCreateInfo colorBlendState {</div>
<div class="line">          {},</div>
<div class="line">          <span class="keyword">false</span>,</div>
<div class="line">          {},</div>
<div class="line">          colorBlendAttachmentState,</div>
<div class="line">      };</div>
<div class="line">      <span class="keyword">constexpr</span> vk::PipelineDynamicStateCreateInfo dynamicState{};</div>
<div class="line">      <span class="keyword">const</span> vk::raii::Pipeline pipeline { gpu.device, <span class="keyword">nullptr</span>, vk::StructureChain {</div>
<div class="line">          vk::GraphicsPipelineCreateInfo {</div>
<div class="line">              {},</div>
<div class="line">              stages,</div>
<div class="line">              &amp;vertexInputState,</div>
<div class="line">              &amp;inputAssemblyState,</div>
<div class="line">              <span class="keyword">nullptr</span>,</div>
<div class="line">              &amp;viewportState,</div>
<div class="line">              &amp;rasterizationState,</div>
<div class="line">              &amp;multisampleState,</div>
<div class="line">              <span class="keyword">nullptr</span>,</div>
<div class="line">              &amp;colorBlendState,</div>
<div class="line">              &amp;dynamicState,</div>
<div class="line">              *pipelineLayout,</div>
<div class="line">          },</div>
<div class="line">          vk::PipelineRenderingCreateInfo {</div>
<div class="line">              {},</div>
<div class="line">              image.format,</div>
<div class="line">          },</div>
<div class="line">      }.get() };</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Since the fields cannot be inlined, logic flow direction is not directly forward, and the code is less readable. </p>
</details>
<hr  />
<p>Such a hard work! For real application, you would make hundred or thousand pipelines with different shader combinations. Repeating this would blow your head. Let's see how <em>vku</em> handles this.</p>
<p><em>vku</em> combines the shader module loading, generation and <code>vk::GraphicsPipelineCreateInfo</code> generation into a single function.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::PipelineLayout pipelineLayout { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Pipeline pipeline { gpu.device, <span class="keyword">nullptr</span>, vk::StructureChain {</div>
<div class="line">        vku::getDefaultGraphicsPipelineCreateInfo(</div>
<div class="line">            vku::createPipelineStages(</div>
<div class="line">                gpu.device,</div>
<div class="line">                <a class="code hl_function" href="structvku_1_1Shader.html#a5089098c11057b7ba4b6e9f0ecdb03bc">vku::Shader::fromSpirvFile</a>(COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.vert.spv&quot;</span> <span class="comment">/* path */</span>, vk::ShaderStageFlagBits::eVertex),</div>
<div class="line">                <a class="code hl_function" href="structvku_1_1Shader.html#a5089098c11057b7ba4b6e9f0ecdb03bc">vku::Shader::fromSpirvFile</a>(COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.frag.spv&quot;</span> <span class="comment">/* path */</span>, vk::ShaderStageFlagBits::eFragment)).get(),</div>
<div class="line">            *pipelineLayout, 1 <span class="comment">/* colorAttachmentCount */</span>) <span class="comment">// stages</span></div>
<div class="line">            .setPRasterizationState(vku::unsafeAddress(vk::PipelineRasterizationStateCreateInfo {</div>
<div class="line">                {},</div>
<div class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>,</div>
<div class="line">                vk::PolygonMode::eFill,</div>
<div class="line">                vk::CullModeFlagBits::eNone, {},</div>
<div class="line">                {}, {}, {}, {},</div>
<div class="line">                1.f,</div>
<div class="line">            }))</div>
<div class="line">            .setPViewportState(vku::unsafeAddress(vk::PipelineViewportStateCreateInfo {</div>
<div class="line">                {},</div>
<div class="line">                vku::unsafeProxy(vku::toViewport(vku::toExtent2D(image.extent))),</div>
<div class="line">                vku::unsafeProxy(vk::Rect2D { { 0, 0 }, vku::toExtent2D(image.extent) }),</div>
<div class="line">            }))</div>
<div class="line">            .setPDynamicState(vku::unsafeAddress(vk::PipelineDynamicStateCreateInfo{})),</div>
<div class="line">        vk::PipelineRenderingCreateInfo {</div>
<div class="line">            {},</div>
<div class="line">            image.format,</div>
<div class="line">        },</div>
<div class="line">    }.get() };</div>
<div class="line">}</div>
<div class="ttc" id="astructvku_1_1Shader_html_a5089098c11057b7ba4b6e9f0ecdb03bc"><div class="ttname"><a href="structvku_1_1Shader.html#a5089098c11057b7ba4b6e9f0ecdb03bc">vku::Shader::fromSpirvFile</a></div><div class="ttdeci">static RefHolder&lt; Shader, std::vector&lt; std::byte &gt; &gt; fromSpirvFile(const std::filesystem::path &amp;path, vk::ShaderStageFlagBits stage, const vk::SpecializationInfo *pSpecializationInfo=nullptr, const char *entryPoint=&quot;main&quot;)</div><div class="ttdoc">Create Shader from compiled SPIR-V file.</div><div class="ttdef"><b>Definition</b> Shader.cppm:105</div></div>
</div><!-- fragment --><p>What happened? Let's see the explanation:</p>
<ol type="1">
<li><p class="startli"><code>vku::getDefaultGraphicsPipelineCreateInfo</code> is the function that returns a "standard" <code>vk::GraphicsPipelineCreateInfo</code>. The term "standard" means the most commonly used settings, which are:</p><ul>
<li>No vertex input state.</li>
<li>Input assembly state with triangle list topology and no primitive restart.</li>
<li>Single viewport and scissor with unspecified value, i.e. are set by dynamic state.</li>
<li>Rasterization state with fill mode and <b>backface culling</b>, line width <code>1.0</code>.</li>
<li>No depth stencil state.</li>
<li>No color blending for all color attachments.</li>
<li>Dynamic state enabled with viewport and scissor.</li>
</ul>
<p class="startli">Its function signature is </p><div class="fragment"><div class="line">++</div>
<div class="line">  getDefaultGraphicsPipelineCreateInfo(</div>
<div class="line">     vk::ArrayProxyNoTemporaries&lt;const vk::PipelineShaderStageCreateInfo&gt; stages,</div>
<div class="line">     vk::PipelineLayout layout,</div>
<div class="line">     std::uint32_t colorAttachmentCount = 0,</div>
<div class="line">     <span class="keywordtype">bool</span> hasDepthStencilAttachment = <span class="keyword">false</span>,</div>
<div class="line">     vk::SampleCountFlagBits multisample = vk::SampleCountFlagBits::e1</div>
<div class="line">  ) -&gt; vk::GraphicsPipelineCreateInfo</div>
</div><!-- fragment --><p> Each parameter represents:</p><ul>
<li><code>stages</code>: Array of <code>vk::PipelineShaderStageCreateInfo</code>s. Since shader is mandatory for Vulkan pipeline creation (among the graphics and compute pipeline), it is required parameter.</li>
<li><code>layout</code>: Pipeline layout object, also mandatory.</li>
<li><code>colorAttachmentCount</code>: The count of the color attachments. It is used for the color blend attachment state array size. For now, we only have one color attachment, so it is <code>1</code>. It is defaulted by <code>0</code> (no color attachment).</li>
<li><code>hasDepthStencilAttachment</code>: Boolean flag for whether pipeline has depth stencil attachment. For now, we don't have depth stencil attachment, so it <code>false</code> (and omitted since it is defaulted by <code>false</code>).</li>
<li><code>multisample</code>: The sample count of the rasterization. Since we're not using MSAA for now, it is <code>vk::SmapleCountFlagBits::e1</code> (and omitted since it is default).</li>
</ul>
<p class="startli">Most of your use case would not heavily vary from this standard pipeline setting, but some of them would. For such cases, you can modify the returned <code>vk::GraphicsPipelineCreateInfo</code> manually by using the Vulkan-Hpp's setter methods with builder pattern. In above code, we modified the rasterization/viewport/dynamic state by using <code>setPRasterizationState</code>, <code>setPViewportState</code>, and <code>setPDynamicState</code> methods.</p>
</li>
<li><p class="startli"><code>vku::createPipelineStages</code> is the function that creates the <code>RefHolder</code> of <code>vk::PipelineShaderStageCreateInfo</code> array from the shader path/code/raw GLSL string. It accepts the device and an arbitrary number of <code><a class="el" href="structvku_1_1Shader.html" title="A lightweight representation of SPIR-V shader code and additional information (stage,...">vku::Shader</a></code>s that have the shader code and stage flag. The function signature is </p><div class="fragment"><div class="line">++</div>
<div class="line">  createPipelineStages(</div>
<div class="line">     <span class="keyword">const</span> vk::raii::Device &amp;device, </div>
<div class="line">     <span class="keyword">const</span> Shaders &amp;...shaders</div>
<div class="line">  ) -&gt; RefHolder&lt;std::array&lt;vk::PipelineShaderStageCreateInfo, <span class="keyword">sizeof</span>...(Shaders)&gt;, std::array&lt;vk::raii::ShaderModule, <span class="keyword">sizeof</span>...(Shaders)&gt;&gt;</div>
</div><!-- fragment --><p> Each parameter represents:</p><ul>
<li><code>device</code>: The Vulkan device which creates the shader modules.</li>
<li><code>shaders</code>: The <code><a class="el" href="structvku_1_1Shader.html" title="A lightweight representation of SPIR-V shader code and additional information (stage,...">vku::Shader</a></code> objects that represent the shader codes and their infos, such like shader stage (<code>vk::ShaderStageFlagBits</code>), specialization constants (<code>nullptr</code> by default) and entry point (<code>"main"</code> by default). You can construct the struct by existing SPIR-V binary (any contiguous range of <code>std::uint32_t</code>s that can be convertible to <code>std::span&lt;const std::uint32_t&gt;</code>), or you may use a convenient functions like <code><a class="el" href="structvku_1_1Shader.html#a5089098c11057b7ba4b6e9f0ecdb03bc" title="Create Shader from compiled SPIR-V file.">vku::Shader::fromSpirvFile</a></code> (load SPIR-V compiled binary from the file directly) or</li>
</ul>
<p class="startli">And since the result is <code><a class="el" href="classvku_1_1RefHolder.html" title="A container type that can be contextually converted to a reference of type T, which has references fo...">vku::RefHolder</a></code> of the <code>vk::PipelineShaderStageCreateInfo</code> array, you can finally get the lvalue reference of inner stage create infos by calling the <code>get()</code> method.</p>
<p class="startli">Thanks to the shaderc, you may just load the raw GLSL string and compile it to the SPIR-V code at runtime. Here's the example:</p>
<p class="startli"><code>vcpkg.json</code> </p><div class="fragment"><div class="line">{</div>
<div class="line">   &quot;dependencies&quot;: [</div>
<div class="line">      {</div>
<div class="line">         &quot;name&quot;: &quot;vku&quot;,</div>
<div class="line">         &quot;features&quot;: [</div>
<div class="line">            &quot;shaderc&quot;</div>
<div class="line">         ]</div>
<div class="line">      }</div>
<div class="line">   ]</div>
<div class="line">}</div>
</div><!-- fragment --><p class="startli"><code>main.cpp</code> </p><div class="fragment"><div class="line">++</div>
<div class="line"><span class="preprocessor">  #include &lt;shaderc/shaderc.hpp&gt;</span></div>
<div class="line">  </div>
<div class="line">  <span class="keyword">const</span> shaderc::Compiler compiler;</div>
<div class="line">  </div>
<div class="line">  vku::getGraphicsPipelineCreateInfo(</div>
<div class="line">      vku::createPipelineStages(</div>
<div class="line">          gpu.device,</div>
<div class="line">          <a class="code hl_function" href="structvku_1_1Shader.html#ab6eee8151a23d0b1c65af87145bf76ec">vku::Shader::fromGLSLFile</a>(compiler, COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.vert&quot;</span> <span class="comment">/* path */</span>, {} <span class="comment">/* compile option */</span>, vk::ShaderStageFlagBits::eVertex),</div>
<div class="line">          <a class="code hl_function" href="structvku_1_1Shader.html#ab6eee8151a23d0b1c65af87145bf76ec">vku::Shader::fromGLSLFile</a>(compiler, COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.frag&quot;</span> <span class="comment">/* path */</span>, {} <span class="comment">/* compile option */</span>, vk::ShaderStageFlagBits::eFragment)</div>
<div class="line">      ).get(),</div>
<div class="line">      *pipelineLayout, 1)</div>
<div class="line">     ... <span class="comment">// Other pipeline settings</span></div>
<div class="ttc" id="astructvku_1_1Shader_html_ab6eee8151a23d0b1c65af87145bf76ec"><div class="ttname"><a href="structvku_1_1Shader.html#ab6eee8151a23d0b1c65af87145bf76ec">vku::Shader::fromGLSLFile</a></div><div class="ttdeci">static RefHolder&lt; Shader, std::vector&lt; std::uint32_t &gt; &gt; fromGLSLFile(shaderc::Compiler compiler, const std::filesystem::path &amp;glslPath, vk::ShaderStageFlagBits stage, const shaderc::CompileOptions &amp;compileOptions, const vk::SpecializationInfo *pSpecializationInfo=nullptr)</div><div class="ttdoc">Create Shader from GLSL file.</div><div class="ttdef"><b>Definition</b> Shader.cppm:180</div></div>
</div><!-- fragment --></li>
<li>Some <em>vku</em>'s utility functions are used:<ul>
<li><code>vku::toExtent2D(const vk::Extent3D &amp;extent)</code>: drop the <code>depth</code> field of the <code>extent</code> and return it. Useful when you're working with 2D image (whose <code>depth</code> is <code>1</code>).</li>
<li><code>vku::toViewport(const vk::Extent2D &amp;extent, bool negativeViewport = false)</code>: create <code>vk::Viewport</code> with bound <code>[0, 0]x[extent.width, extent.height]</code> and depth <code>[0, 1]</code>. If <code>negativeViewport</code> is <code>true</code>, the viewport's height is flipped (i.e. <code>[extent.height, 0]</code>).</li>
</ul>
</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>These are common pitfalls of <code>getDefaultGraphicsPipelineCreateInfo</code> usage.<ol type="1">
<li><b>The default cull mode is backface culling</b>. If you want to disable the culling, you have to modify the returned struct manually.</li>
<li>Even if you passed the <code>hasDepthStencilAttachment</code> parameter to <code>true</code>, depth testing/writing is not enabled. For this, you have to modify the returned struct manually.</li>
<li><em>vku</em> stores these standard graphics pipeline properties into the static storage, therefore you don't have to worry about the returned <code>vk::GraphicsPipelineCreateInfo</code>'s lifetime validity. Due to this approach, the maximum number of color attachments is limited to <code>8</code>. I don't think this is a big issue, but you can modify the <code>MAX_COLOR_ATTACHMENT_COUNT</code> if you want to increase the limit.</li>
</ol>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="structvku_1_1Shader.html" title="A lightweight representation of SPIR-V shader code and additional information (stage,...">vku::Shader</a></code> neither represents the <code>vk::ShaderModule</code>, nor constructs the shader module. It only holds the SPIR-V shader code and its info. The shader module is created by calling <code>vku::createPipelineStages</code> function.</dd>
<dd>
Runtime GLSL compilation feature is not enabled by default. You have to manually set the CMake variable <code>VKU_USE_SHADERC</code> to <code>ON</code>, or specify the port feature <code>shaderc</code> if you're using vcpkg.</dd></dl>
<h2><a class="anchor" id="autotoc_md21"></a>
4.3. Enabling the Dynamic Rendering Feature</h2>
<p>If you launch your application now, it will emit the validation error:</p>
<details >
<summary >
Show errors</summary>
<p></p>
<blockquote class="doxtable">
<p>&zwj;VUID-VkGraphicsPipelineCreateInfo-pNext-pNext(ERROR / SPEC): msgNum: 395890785 - Validation Error: [ VUID-VkGraphicsPipelineCreateInfo-pNext-pNext ] Object 0: handle = 0x121008200, type = VK_OBJECT_TYPE_INSTANCE; | MessageID = 0x1798d061 | vkCreateGraphicsPipelines(): pCreateInfos[0].pNext includes a pointer to a VkStructureType (VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO), but its parent extension VK_KHR_dynamic_rendering has not been enabled. The Vulkan spec states: Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkAttachmentSampleCountInfoAMD, VkExternalFormatANDROID, VkGraphicsPipelineLibraryCreateInfoEXT, VkGraphicsPipelineShaderGroupsCreateInfoNV, VkMultiviewPerViewAttributesInfoNVX, VkPipelineCompilerControlCreateInfoAMD, VkPipelineCreateFlags2CreateInfoKHR, VkPipelineCreationFeedbackCreateInfo, VkPipelineDiscardRectangleStateCreateInfoEXT, VkPipelineFragmentShadingRateEnumStateCreateInfoNV, VkPipelineFragmentShadingRateStateCreateInfoKHR, VkPipelineLibraryCreateInfoKHR, VkPipelineRenderingCreateInfo, VkPipelineRepresentativeFragmentTestStateCreateInfoNV, VkPipelineRobustnessCreateInfoEXT, VkRenderingAttachmentLocationInfoKHR, or VkRenderingInputAttachmentIndexInfoKHR (<a href="https://vulkan.lunarg.com/doc/view/1.3.283.0/mac/1.3-extensions/vkspec.html#VUID-VkGraphicsPipelineCreateInfo-pNext-pNext">https://vulkan.lunarg.com/doc/view/1.3.283.0/mac/1.3-extensions/vkspec.html#VUID-VkGraphicsPipelineCreateInfo-pNext-pNext</a>) Objects: 1 [0] 0x121008200, type: 1, name: NULL VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576(ERROR / SPEC): msgNum: 264898451 - Validation Error: [ VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576 ] | MessageID = 0xfca0793 | vkCreateGraphicsPipelines(): pCreateInfos[0].renderPass is NULL, but the dynamicRendering feature was not enabled. The Vulkan spec states: If the dynamicRendering feature is not enabled and the pipeline requires pre-rasterization shader state, fragment shader state, or fragment output interface state, renderPass must not be VK_NULL_HANDLE (<a href="https://vulkan.lunarg.com/doc/view/1.3.283.0/mac/1.3-extensions/vkspec.html#VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576">https://vulkan.lunarg.com/doc/view/1.3.283.0/mac/1.3-extensions/vkspec.html#VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576</a>) Objects: 0 Process finished with exit code 134 (interrupted by signal 6:SIGABRT) </p>
</blockquote>
</details>
<p>Since <code>VK_KHR_dynamic_rendering</code> extension core from Vulkan 1.3, and we're using Vulkan 1.0, the extension have to be explicitly specified at the device creation. Also, you have to pass the <code>vk::PhysicalDeviceDynamicRenderingFeatures</code> struct into <code>vk::DeviceCreateInfo</code>'s <code>pNext</code> chain.</p>
<p>Setting device extension is already explained in above. How we can specify the <code>vk::DeviceCreateInfo</code>'s <code>pNext</code>? <em>vku</em> provides these mechanism with compile-time safe way. You can specify the <code>vk::DeviceCreateInfo</code>'s <code>pNext</code> chain by using the <code><a class="el" href="structvku_1_1Gpu_1_1Config.html">vku::Gpu::Config</a></code>'s <code>devicePNexts</code> field. Here's the code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1Gpu.html">vku::Gpu&lt;QueueFamilies, Queues&gt;</a> gpu { instance, <a class="code hl_struct" href="structvku_1_1Gpu_1_1Config.html">vku::Gpu&lt;QueueFamilies, Queues&gt;::Config</a> {</div>
<div class="line">    .verbose = <span class="keyword">true</span>,</div>
<div class="line">    .deviceExtensions = {</div>
<div class="line">        vk::KHRMaintenance2ExtensionName, <span class="comment">// for VK_KHR_depth_stencil_resolve</span></div>
<div class="line">        vk::KHRCreateRenderpass2ExtensionName, <span class="comment">// for VK_KHR_depth_stencil_resolve</span></div>
<div class="line">        vk::KHRDepthStencilResolveExtensionName, <span class="comment">// for VK_KHR_multiview</span></div>
<div class="line">        vk::KHRMultiviewExtensionName, <span class="comment">// for VK_KHR_dynamic_rendering</span></div>
<div class="line">        vk::KHRDynamicRenderingExtensionName,</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">        vk::KHRPortabilitySubsetExtensionName,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">    },</div>
<div class="line">    .devicePNexts = std::tuple {</div>
<div class="line">        vk::PhysicalDeviceDynamicRenderingFeatures { <span class="keyword">true</span> },</div>
<div class="line">    },</div>
<div class="line">} };</div>
</div><!-- fragment --><p>You can pass the tuple of Vulkan structures that are used for the <code>pNext</code> chain of <code>vk::DeviceCreateInfo</code>. <em>vku</em> will enclose the concatenated <code>vk::DeviceCreateInfo</code> and this tuple into <code>vk::StructureChain</code>, so you can take the advantage of compile time pNext chain validation.</p>
<dl class="section note"><dt>Note</dt><dd><code><a class="el" href="classvku_1_1Gpu.html" title="Bootstrapper for Vulkan RAII physical device, device, allocator creation.">vku::Gpu</a>&lt;QueueFamilies, Queues&gt;::Config</code> is a templated class, whose template types are tuple alternatives. Therefore, depending on your compiler's C++23 implementation status, these type deduction may not work (especially for MSVC). For this, you have to manually specify the tuple alternative types, like: <code><a class="el" href="classvku_1_1Gpu.html" title="Bootstrapper for Vulkan RAII physical device, device, allocator creation.">vku::Gpu</a>&lt;QueueFamilies, Queues&gt;::Config&lt;vk::PhysicalDeviceDynamicRenderingFeatures&gt;</code>.</dd></dl>
<p>After enabling the dynamic rendering feature, running your application will not emit the validation error anymore.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
5. Recording the Command Buffer and Submitting the Rendering Commands into the Queue</h1>
<p>For this step, we have to create the command buffer, record the rendering commands, and submit the command buffer into the graphics queue. Here's the Vulkan-Hpp code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Pipeline pipeline { ... };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> vk::raii::CommandPool graphicsCommandPool { gpu.device, vk::CommandPoolCreateInfo { </div>
<div class="line">        {}, <span class="comment">// flags</span></div>
<div class="line">        gpu.queueFamilies.graphics,</div>
<div class="line">    } };</div>
<div class="line">    <span class="keyword">const</span> vk::CommandBuffer commandBuffer = (*gpu.device).allocateCommandBuffers(vk::CommandBufferAllocateInfo {</div>
<div class="line">        *graphicsCommandPool,</div>
<div class="line">        vk::CommandBufferLevel::ePrimary,</div>
<div class="line">        1, <span class="comment">// commandBufferCount</span></div>
<div class="line">    })[0];</div>
<div class="line"> </div>
<div class="line">    commandBuffer.begin({ vk::CommandBufferUsageFlagBits::eOneTimeSubmit <span class="comment">/* flags */</span> });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Change the layout of image to ColorAttachmentOptimal.</span></div>
<div class="line">    commandBuffer.pipelineBarrier(</div>
<div class="line">        vk::PipelineStageFlagBits::eTopOfPipe, <span class="comment">// srcStageMask</span></div>
<div class="line">        vk::PipelineStageFlagBits::eColorAttachmentOutput, <span class="comment">// dstStageMask</span></div>
<div class="line">        {}, {}, {}, <span class="comment">// dependencyFlags, memoryBarriers, bufferMemoryBarriers</span></div>
<div class="line">        vk::ImageMemoryBarrier {</div>
<div class="line">            {}, <span class="comment">// srcAccessMask</span></div>
<div class="line">            vk::AccessFlagBits::eColorAttachmentWrite, <span class="comment">// dstAccessMask</span></div>
<div class="line">            {}, <span class="comment">// oldLayout</span></div>
<div class="line">            vk::ImageLayout::eColorAttachmentOptimal, <span class="comment">// newLayout</span></div>
<div class="line">            vk::QueueFamilyIgnored, <span class="comment">// srcQueueFamilyIndex</span></div>
<div class="line">            vk::QueueFamilyIgnored, <span class="comment">// dstQueueFamilyIndex</span></div>
<div class="line">            image, vku::fullSubresourceRange(),</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Dynamic rendering.</span></div>
<div class="line">    commandBuffer.beginRenderingKHR({</div>
<div class="line">        {}, <span class="comment">// flags</span></div>
<div class="line">        { { 0, 0 }, vku::toExtent2D(image.extent) }, <span class="comment">// renderArea</span></div>
<div class="line">        1, <span class="comment">// layerCount</span></div>
<div class="line">        0, <span class="comment">// viewMask</span></div>
<div class="line">        vku::unsafeProxy(vk::RenderingAttachmentInfo {</div>
<div class="line">            *imageView, vk::ImageLayout::eColorAttachmentOptimal,</div>
<div class="line">            {}, {}, {}, <span class="comment">// resolveMode, resolveImageView, resolveImageLayout</span></div>
<div class="line">            vk::AttachmentLoadOp::eClear,vk::AttachmentStoreOp::eStore, vk::ClearColorValue { 0.f, 0.f, 0.f, 0.f },</div>
<div class="line">        }), <span class="comment">// colorAttachments</span></div>
<div class="line">    }, *gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw triangle.</span></div>
<div class="line">    commandBuffer.bindPipeline(vk::PipelineBindPoint::eGraphics, *pipeline);</div>
<div class="line">    commandBuffer.draw(3 <span class="comment">/* vertexCount */</span>, 1 <span class="comment">/* instanceCount */</span>, 0 <span class="comment">/* firstVertex */</span>, 0 <span class="comment">/* firstInstance */</span>);</div>
<div class="line"> </div>
<div class="line">    commandBuffer.endRenderingKHR(*gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">    commandBuffer.end();</div>
<div class="line"> </div>
<div class="line">    gpu.queues.graphics.submit(vk::SubmitInfo {</div>
<div class="line">        {}, <span class="comment">// waitSemaphores</span></div>
<div class="line">        {}, <span class="comment">// waitDstStageMask</span></div>
<div class="line">        commandBuffer, <span class="comment">// commandBuffers</span></div>
<div class="line">    });</div>
<div class="line">    gpu.queues.graphics.waitIdle();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you're not familiar about how to use the <code>VK_KHR_dynamic_rendering</code> extension, see <a href="https://docs.vulkan.org/features/latest/features/proposals/VK_KHR_dynamic_rendering.html#_rendering_with_a_dynamic_render_pass">Vulkan documentation</a> for more detailed explanation.</p>
<p>We allocated the command buffer from graphics command pool, change the image layout for color attachment usage, and do triangle rendering with the dynamic rendering scope. As mentioned above, since dynamic rendering feature is not core until Vulkan 1.3, you have to pass the dispatcher object to the <code>beginRenderingKHR</code> and <code>endRenderingKHR</code> functions (which can be omitted if you're using Vulkan 1.3).</p>
<dl class="section remark"><dt>Remarks</dt><dd>You can set <code>VKU_DEFAULT_DYNAMIC_DISPATCHER</code> CMake variable at the configuration time, or add <code>dynamic-dispatcher</code> feature when use vcpkg to make Vulkan-Hpp uses dynamically loaded function pointers. For this feature, see <a class="el" href="md_docs_2using-vku.html">Using vku</a> page and <a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/README.md#extensions--per-device-function-pointers">Vulkan-Hpp documentation</a> for the details. With dynamic dispatch loader, you can omit the last parameter <code>*device.getDispatcher()</code>.</dd></dl>
<p><code>vku::fullSubresourceRange(vk::ImageAspectFlags aspectFlags = vk::ImageApsectFlagBits::eColor)</code> is <em>vku</em>'s utility function that generates the whole subresource region (all mip levels and array layers) with the given aspect flags.</p>
<hr  />
<p>Not a big deal, but <em>vku</em> provides you a simpler mechanism for one-time command buffer allocation and submission, by <code>vku::executeSingleCommand</code>. Here's <em>vku</em> approach:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Pipeline pipeline { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::CommandPool graphicsCommandPool { gpu.device, vk::CommandPoolCreateInfo { {}, gpu.queueFamilies.graphics } };</div>
<div class="line">    vku::executeSingleCommand(*gpu.device, *graphicsCommandPool, gpu.queues.graphics, [&amp;](vk::CommandBuffer cb) {</div>
<div class="line">        cb.pipelineBarrier(</div>
<div class="line">            vk::PipelineStageFlagBits::eTopOfPipe, vk::PipelineStageFlagBits::eColorAttachmentOutput,</div>
<div class="line">            {}, {}, {},</div>
<div class="line">            vk::ImageMemoryBarrier {</div>
<div class="line">                {}, vk::AccessFlagBits::eColorAttachmentWrite,</div>
<div class="line">                {}, vk::ImageLayout::eColorAttachmentOptimal,</div>
<div class="line">                vk::QueueFamilyIgnored, vk::QueueFamilyIgnored,</div>
<div class="line">                image, vku::fullSubresourceRange(),</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">        cb.beginRenderingKHR({</div>
<div class="line">            {},</div>
<div class="line">            { { 0, 0 }, vku::toExtent2D(image.extent) },</div>
<div class="line">            1,</div>
<div class="line">            0,</div>
<div class="line">            vku::unsafeProxy(vk::RenderingAttachmentInfo {</div>
<div class="line">                *imageView, vk::ImageLayout::eColorAttachmentOptimal,</div>
<div class="line">                {}, {}, {},</div>
<div class="line">                vk::AttachmentLoadOp::eClear, vk::AttachmentStoreOp::eStore, vk::ClearColorValue { 0.f, 0.f, 0.f, 0.f },</div>
<div class="line">            }),</div>
<div class="line">        }, *gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">        cb.bindPipeline(vk::PipelineBindPoint::eGraphics, *pipeline);</div>
<div class="line">        cb.draw(3, 1, 0, 0);</div>
<div class="line"> </div>
<div class="line">        cb.endRenderingKHR(*gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">        cb.pipelineBarrier(</div>
<div class="line">            vk::PipelineStageFlagBits::eColorAttachmentOutput, vk::PipelineStageFlagBits::eTransfer,</div>
<div class="line">            {}, {}, {},</div>
<div class="line">            vk::ImageMemoryBarrier {</div>
<div class="line">                vk::AccessFlagBits::eColorAttachmentWrite, vk::AccessFlagBits::eTransferRead,</div>
<div class="line">                vk::ImageLayout::eColorAttachmentOptimal, vk::ImageLayout::eTransferSrcOptimal,</div>
<div class="line">                vk::QueueFamilyIgnored, vk::QueueFamilyIgnored,</div>
<div class="line">                image, vku::fullSubresourceRange(),</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">        cb.copyImageToBuffer(</div>
<div class="line">            image, vk::ImageLayout::eTransferSrcOptimal,</div>
<div class="line">            destagingBuffer,</div>
<div class="line">            vk::BufferImageCopy {</div>
<div class="line">                0, 0, 0,</div>
<div class="line">                { vk::ImageAspectFlagBits::eColor, 0, 0, 1 },</div>
<div class="line">                vk::Offset3D{}, image.extent,</div>
<div class="line">            });</div>
<div class="line">    });</div>
<div class="line">    gpu.queues.graphics.waitIdle();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Command buffer allocation and submission code is gone. <code>vku::executeSingleCommand</code> automatically allocates a command buffer from the given command pool, begins before/ends after the given command buffer recording function execution, and submits the command buffer into the given queue.</p>
<p>For optimization, since it knows only a single command buffer have to be allocated (allocation count is known at the compile time), it uses <code>vku::allocateCommandBuffers&lt;N&gt;</code> to avoid the heap allocation.</p>
<p>You can optionally pass the <code>vk::Fence</code> handle to the last parameter. With fence, it signaled when the submitted command buffer execution finished. Otherwise, <em>vku</em> does not handle any synchronization, therefore we should wait for the graphics queue to be idle manually.</p>
<h2><a class="anchor" id="autotoc_md24"></a>
5.1. Check Your First Triangle with Debuggers</h2>
<p>We reached our goal now! The application will render the colored triangle into <code>image</code>. However, you can't see the result because there's no mechanism for image visualization or persisting it into the file. We'll implement it in the next section, but for the intermediate check, you can use the Vulkan debugger tools like RenderDoc, Nsight Graphics or Xcode Metal Debugger (if you're running it with MoltenVK).</p>
<dl class="section note"><dt>Note</dt><dd>This section is MoltenVK specific.</dd></dl>
<p>To use the Metal Debugger, I'll run the application with the following environment variables, explained in the <a href="https://github.com/KhronosGroup/MoltenVK/blob/main/Docs/MoltenVK_Runtime_UserGuide.md#debugging-your-moltenvk-application-using-metal-frame-capture">MoltenVK Runtime User Guide</a>.</p>
<ul>
<li><code>METAL_CAPTURE_ENABLED=1</code></li>
<li><code>MVK_CONFIG_AUTO_GPU_CAPTURE_SCOPE=1</code></li>
<li><code>MVK_CONFIG_AUTO_GPU_CAPTURE_OUTPUT_FILE=output.gputrace</code></li>
</ul>
<p>After the application execution, <code>output.gputrace</code> file will be created in the executable folder. You can see the result image by opening it.</p>
<div class="image">
<img src="xcode-metal-debugger.png" alt=""/>
<div class="caption">
Screenshot of Xcode Metal Debugger</div></div>
    <h1><a class="anchor" id="autotoc_md25"></a>
6. De-staging the Image Data into Host Accessible Buffer and Saving it</h1>
<p>If you can't use the GPU debugging tool, you can de-stage the image data into the host accessible buffer and save it into the file. With Vulkan-Hpp, the step would be:</p>
<ol type="1">
<li>Creating a de-staging buffer with proper allocation size.</li>
<li>Append the copy command to the previous rendering commands (and executing it).</li>
<li>Map the de-staging buffer memory into CPU address and read it.</li>
<li>Save the fetched data into file (uses a function like <code>stbi_write_png</code>).</li>
</ol>
<h2><a class="anchor" id="autotoc_md26"></a>
6.1. Creating Buffer for De-staging</h2>
<p>Alike <code><a class="el" href="structvku_1_1AllocatedImage.html" title="Owning image handle with memory allocation.">vku::AllocatedImage</a></code>, <em>vku</em> also offers you to use RAII wrapped buffer objects. But in this case, you have two options: <code><a class="el" href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation.">vku::AllocatedBuffer</a></code> and <code><a class="el" href="classvku_1_1MappedBuffer.html" title="Owning buffer handle with memory allocation and CPU-accessible mapped data.">vku::MappedBuffer</a></code>. Here's the classes' hierarchy:</p>
<div class="image">
<img src="vku-buffer-hierarchy.png" alt=""/>
<div class="caption">
Hierarchy of vku::Buffer, vku::AllocatedBuffer, and vku::MappedBuffer</div></div>
    <p><code><a class="el" href="structvku_1_1Buffer.html" title="Non-owning vk::Buffer handle with the additional information.">vku::Buffer</a></code> and <code><a class="el" href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation.">vku::AllocatedBuffer</a></code>'s relation has the same manner as <code><a class="el" href="structvku_1_1Image.html" title="Non-owning vk::Image handle with the additional information.">vku::Image</a></code> and <code><a class="el" href="structvku_1_1AllocatedImage.html" title="Owning image handle with memory allocation.">vku::AllocatedImage</a></code>. <code><a class="el" href="classvku_1_1MappedBuffer.html" title="Owning buffer handle with memory allocation and CPU-accessible mapped data.">vku::MappedBuffer</a></code> is type of <code><a class="el" href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation.">vku::AllocatedBuffer</a></code> (it owns the allocation), but one thing is different: it is persistently mapped buffer during its lifetime (mapped at construction, unmapped at destruction). Since the buffer data can be viewed by the host side, it exposes the methods about viewing its data by arbitrary type of reference (<code>asValue&lt;T&gt;</code>) or contiguous range (<code>asRange&lt;T&gt;</code>). It mostly used as host-device data transfer.</p>
<p>Since we're going to use the buffer for the de-staging purpose, we'll use the <code><a class="el" href="classvku_1_1MappedBuffer.html" title="Owning buffer handle with memory allocation and CPU-accessible mapped data.">vku::MappedBuffer</a></code> for this step. Here's the code:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1Gpu.html">vku::Gpu&lt;QueueFamilies, Queues&gt;</a> gpu { ... };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { gpu.allocator, vk::ImageCreateInfo {</div>
<div class="line">        {},</div>
<div class="line">        vk::ImageType::e2D,</div>
<div class="line">        vk::Format::eR8G8B8A8Unorm,</div>
<div class="line">        vk::Extent3D { 512, 512, 1 },</div>
<div class="line">        1, 1,</div>
<div class="line">        vk::SampleCountFlagBits::e1,</div>
<div class="line">        vk::ImageTiling::eOptimal,</div>
<div class="line">        vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eTransferSrc, <span class="comment">// &lt;- TransferSrc added</span></div>
<div class="line">    } };</div>
<div class="line">    <span class="keyword">const</span> vk::raii::ImageView imageView { ... };</div>
<div class="line">    </div>
<div class="line">    ...</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Pipeline pipeline { ... };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1MappedBuffer.html">vku::MappedBuffer</a> destagingBuffer { gpu.allocator, vk::BufferCreateInfo {</div>
<div class="line">        {},</div>
<div class="line">        blockSize(image.format) * image.extent.width * image.extent.height,</div>
<div class="line">        vk::BufferUsageFlagBits::eTransferDst,</div>
<div class="line">    }, vku::allocation::hostRead }; <span class="comment">// &lt;- Buffer declaration.</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> vk::raii::CommandPool graphicsCommandPool { gpu.device, vk::CommandPoolCreateInfo { {}, gpu.queueFamilies.graphics } };</div>
<div class="line">    vku::executeSingleCommand(*gpu.device, *graphicsCommandPool, gpu.queues.graphics, [&amp;](vk::CommandBuffer cb) {</div>
<div class="line">        ...</div>
<div class="line"> </div>
<div class="line">        cb.endRenderingKHR(*gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// New code starts from here:</span></div>
<div class="line">        <span class="comment">// Change the layout of image for transfer source.</span></div>
<div class="line">        cb.pipelineBarrier(</div>
<div class="line">            vk::PipelineStageFlagBits::eColorAttachmentOutput, vk::PipelineStageFlagBits::eTransfer,</div>
<div class="line">            {}, {}, {},</div>
<div class="line">            vk::ImageMemoryBarrier {</div>
<div class="line">                vk::AccessFlagBits::eColorAttachmentWrite, vk::AccessFlagBits::eTransferRead,</div>
<div class="line">                vk::ImageLayout::eColorAttachmentOptimal, vk::ImageLayout::eTransferSrcOptimal,</div>
<div class="line">                vk::QueueFamilyIgnored, vk::QueueFamilyIgnored,</div>
<div class="line">                image, vku::fullSubresourceRange(),</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">        cb.copyImageToBuffer(</div>
<div class="line">            image, vk::ImageLayout::eTransferSrcOptimal,</div>
<div class="line">            destagingBuffer,</div>
<div class="line">            vk::BufferImageCopy {</div>
<div class="line">                0, 0, 0,</div>
<div class="line">                { vk::ImageAspectFlagBits::eColor, 0, 0, 1 },</div>
<div class="line">                vk::Offset3D{}, image.extent,</div>
<div class="line">            });</div>
<div class="line">    });</div>
<div class="line">    gpu.queues.graphics.waitIdle();</div>
<div class="line">}</div>
<div class="ttc" id="aclassvku_1_1MappedBuffer_html"><div class="ttname"><a href="classvku_1_1MappedBuffer.html">vku::MappedBuffer</a></div><div class="ttdoc">Owning buffer handle with memory allocation and CPU-accessible mapped data.</div><div class="ttdef"><b>Definition</b> MappedBuffer.cppm:32</div></div>
</div><!-- fragment --><p>We created <code>destagingBuffer</code> with the required image data size (= (size of a texel) * (image width) * (image height)), and pass <code>allocationCreateInfo</code> as <code>vku::allocation::hostRead</code> constant, which is the constant that is predefined by</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">vma::AllocationCreateInfo {</div>
<div class="line">    vma::AllocationCreateFlagBits::eHostAccessRandom | vma::AllocationCreateFlagBits::eMapped,</div>
<div class="line">    vma::MemoryUsage::eAuto,</div>
<div class="line">}</div>
</div><!-- fragment --><p>. It indicates that the buffer will be read by the CPU later.</p>
<dl class="section warning"><dt>Warning</dt><dd><code><a class="el" href="classvku_1_1MappedBuffer.html#aa8518cf18faffc792ec9fbd3ddc023bd" title="Create mapped buffer.">vku::MappedBuffer::MappedBuffer</a>(vma::Allocator, const vk::BufferCreateInfo&amp;, const vma::AllocationCreateInfo&amp;)</code> constructor's last allocation create info parameter is default by <br  />
<br  />
 <div class="fragment"><div class="line"> ++</div>
<div class="line">vma::AllocationCreateInfo {</div>
<div class="line">   vma::AllocationCreateFlagBits::eHostAccessSequentialWrite | vma::AllocationCreateFlagBits::eMapped,</div>
<div class="line">   vma::MemoryUsage::eAuto,</div>
<div class="line">}</div>
</div><!-- fragment --> Which means omitting the last parameter for host reading may cause the <b>significant</b> performance degradation (especially on the mobile hardware).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd><b>DO NOT pass the non-mappable allocation create flags.</b> If you're passing the non-default <code>allocationCreateInfo</code>, its <code>flags</code> must always contains <code>vma::AllocationCreateFlagBits::eMapped</code> and either one of <code>vma::AllocationCreateFlagBits::eHostAccessSequentialWrite</code> or <code>vma::AllocationCreateFlagBits::eHostAccessRandom</code>. Otherwise, it cannot be mapped, which violates its naming.</dd></dl>
<p>After the buffer creation, we added the command buffer recording code that changes the image layout for transfer source and copies the image data into the buffer. don't forget to add your image usage flag with <code>vk::ImageUsageFlagBits::eTransferSrc</code>.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
6.2. Persisting Image</h2>
<p>After the queue gets idle, the de-staged data gets visible at the host side. Now we can persist the linearly flattened image data by image file, using third party library like <code>stb-image</code>.</p>
<p><code>vcpkg.json</code> </p><div class="fragment"><div class="line">{</div>
<div class="line">  &quot;dependencies&quot;: [</div>
<div class="line">    &quot;vku&quot;,</div>
<div class="line">    &quot;stb&quot;</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>CMakeLists.txt</code> </p><div class="fragment"><div class="line">...</div>
<div class="line"> </div>
<div class="line"># ----------------</div>
<div class="line"># External dependencies.</div>
<div class="line"># ----------------</div>
<div class="line"> </div>
<div class="line">find_package(Stb REQUIRED)</div>
<div class="line">find_package(vku CONFIG REQUIRED)</div>
<div class="line"> </div>
<div class="line"># ----------------</div>
<div class="line"># Project executables.</div>
<div class="line"># ----------------</div>
<div class="line"> </div>
<div class="line">add_executable(vku-tutorial main.cpp impl.cpp) # impl.cpp file added to prevent the duplicated stb_image compilation.</div>
<div class="line">target_include_directories(vku-tutorial PRIVATE ${Stb_INCLUDE_DIR})</div>
<div class="line">target_link_libraries(vku-tutorial PRIVATE vku::vku)</div>
<div class="line">target_compile_definitions(vku-tutorial PRIVATE</div>
<div class="line">    COMPILED_SHADER_DIR=&quot;${CMAKE_CURRENT_SOURCE_DIR}/shaders&quot;</div>
<div class="line">)</div>
</div><!-- fragment --><p><code>main.cpp</code> </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;stb_image_write.h&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">int main() {</div>
<div class="line">    ...</div>
<div class="line">    gpu.queues.graphics.waitIdle();</div>
<div class="line">    </div>
<div class="line">    stbi_write_png(<span class="stringliteral">&quot;output.png&quot;</span>, image.extent.width, image.extent.height, 4, destagingBuffer.data, blockSize(image.format) * image.extent.width);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>impl.cpp</code> </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#define STB_IMAGE_WRITE_IMPLEMENTATION</span></div>
<div class="line"><span class="preprocessor">#include &lt;stb_image_write.h&gt;</span></div>
</div><!-- fragment --><p>After the application launch, you can find the <code>output.png</code> file in the executable folder.</p>
<div class="image">
<img src="final.png" alt=""/>
<div class="caption">
output.png</div></div>
    <hr  />
<p>In the next tutorial, we'll render this triangle into the actual window (using <a href="https://www.glfw.org">GLFW</a>), and how to effectively manage the multiple attachment images with <em>vku</em>. Stay tuned!</p>
<details >
<summary >
Here's the full code of the tutorial.</summary>
<p></p>
<p><code>CMakeLists.txt</code> </p><div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.30)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_EXPERIMENTAL_CXX_IMPORT_STD &quot;0e5b6991-d74f-4b3d-a41c-cf096e0b2508&quot;)</div>
<div class="line">project(vku-tutorial LANGUAGES CXX)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 23)</div>
<div class="line">set(CMAKE_CXX_MODULE_STD 1)</div>
<div class="line"> </div>
<div class="line"># ----------------</div>
<div class="line"># External dependencies.</div>
<div class="line"># ----------------</div>
<div class="line"> </div>
<div class="line">find_package(Stb REQUIRED)</div>
<div class="line">find_package(vku CONFIG REQUIRED)</div>
<div class="line"> </div>
<div class="line"># ----------------</div>
<div class="line"># Project executables.</div>
<div class="line"># ----------------</div>
<div class="line"> </div>
<div class="line">add_executable(vku-tutorial main.cpp impl.cpp)</div>
<div class="line">target_include_directories(vku-tutorial PRIVATE ${Stb_INCLUDE_DIR})</div>
<div class="line">target_link_libraries(vku-tutorial PRIVATE vku::vku)</div>
<div class="line">target_compile_definitions(vku-tutorial PRIVATE</div>
<div class="line">    COMPILED_SHADER_DIR=&quot;${CMAKE_CURRENT_SOURCE_DIR}/shaders&quot;</div>
<div class="line">)</div>
</div><!-- fragment --><p><code>vcpkg.json</code> </p><div class="fragment"><div class="line">{</div>
<div class="line">   &quot;dependencies&quot;: [</div>
<div class="line">      &quot;vku&quot;,</div>
<div class="line">      &quot;stb&quot;</div>
<div class="line">   ]</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>shaders/triangle.vert</code> </p><div class="fragment"><div class="line">#version 460</div>
<div class="line"> </div>
<div class="line">const vec2 positions[] = {</div>
<div class="line">    { -0.5,  0.5 },</div>
<div class="line">    {  0.5,  0.5 },</div>
<div class="line">    {  0.0, -0.5 },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const vec3 colors[] = {</div>
<div class="line">    { 1.0, 0.0, 0.0 },</div>
<div class="line">    { 0.0, 1.0, 0.0 },</div>
<div class="line">    { 0.0, 0.0, 1.0 },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">layout (location = 0) out vec3 fragColor;</div>
<div class="line"> </div>
<div class="line">void main(){</div>
<div class="line">    fragColor = colors[gl_VertexIndex];</div>
<div class="line">    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>shaders/triangle.frag</code> </p><div class="fragment"><div class="line">#version 450</div>
<div class="line"> </div>
<div class="line">layout (location = 0) in vec3 fragColor;</div>
<div class="line"> </div>
<div class="line">layout (location = 0) out vec4 outColor;</div>
<div class="line"> </div>
<div class="line">void main(){</div>
<div class="line">    outColor = vec4(fragColor, 1.0);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>main.cpp</code> </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;stb_image_write.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> std;</div>
<div class="line"><span class="keyword">import</span> <a class="code" href="module__vku.html">vku</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>QueueFamilies {</div>
<div class="line">    std::uint32_t graphics;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">explicit</span> QueueFamilies(vk::PhysicalDevice physicalDevice)</div>
<div class="line">        : graphics { vku::getGraphicsQueueFamily(physicalDevice.getQueueFamilyProperties()).value() } { }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Queues {</div>
<div class="line">    vk::Queue graphics;</div>
<div class="line"> </div>
<div class="line">    Queues(vk::Device device, <span class="keyword">const</span> QueueFamilies &amp;queueFamilies)</div>
<div class="line">        : graphics { device.getQueue(queueFamilies.graphics, 0) } { }</div>
<div class="line"> </div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">auto</span> getCreateInfos(vk::PhysicalDevice, <span class="keyword">const</span> QueueFamilies &amp;queueFamilies) <span class="keyword">noexcept</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_class" href="classvku_1_1RefHolder.html">vku::RefHolder</a> {</div>
<div class="line">            [=](<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;priority) {</div>
<div class="line">                <span class="keywordflow">return</span> vk::DeviceQueueCreateInfo {</div>
<div class="line">                    {},</div>
<div class="line">                    queueFamilies.graphics,</div>
<div class="line">                    vk::ArrayProxyNoTemporaries(priority),</div>
<div class="line">                };</div>
<div class="line">            },</div>
<div class="line">            1.f,</div>
<div class="line">        };</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">const</span> vk::raii::Context context;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Instance instance { context, vk::InstanceCreateInfo {</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">        vk::InstanceCreateFlagBits::eEnumeratePortabilityKHR,</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">        {},</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        vku::unsafeAddress(vk::ApplicationInfo {</div>
<div class="line">            <span class="stringliteral">&quot;Hello Triangle&quot;</span>, 0,</div>
<div class="line">            <span class="keyword">nullptr</span>, 0,</div>
<div class="line">            vk::makeApiVersion(0, 1, 0, 0),</div>
<div class="line">        }),</div>
<div class="line">        vku::unsafeProxy&lt;const char*&gt;(<span class="stringliteral">&quot;VK_LAYER_KHRONOS_validation&quot;</span>),</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">        vku::unsafeProxy({</div>
<div class="line">            vk::KHRGetPhysicalDeviceProperties2ExtensionName,</div>
<div class="line">            vk::KHRPortabilityEnumerationExtensionName,</div>
<div class="line">        }),</div>
<div class="line">#endif</div>
<div class="line">    } };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1Gpu.html">vku::Gpu&lt;QueueFamilies, Queues&gt;</a> gpu { instance, <a class="code hl_struct" href="structvku_1_1Gpu_1_1Config.html">vku::Gpu&lt;QueueFamilies, Queues&gt;::Config</a> {</div>
<div class="line">         .verbose = <span class="keyword">true</span>,</div>
<div class="line">         .deviceExtensions = {</div>
<div class="line">             vk::KHRMaintenance2ExtensionName,</div>
<div class="line">             vk::KHRCreateRenderpass2ExtensionName,</div>
<div class="line">             vk::KHRDepthStencilResolveExtensionName,</div>
<div class="line">             vk::KHRMultiviewExtensionName,</div>
<div class="line">             vk::KHRDynamicRenderingExtensionName,</div>
<div class="line"><span class="preprocessor">#if __APPLE__</span></div>
<div class="line">             vk::KHRPortabilitySubsetExtensionName,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">         },</div>
<div class="line">         .devicePNexts = std::tuple {</div>
<div class="line">             vk::PhysicalDeviceDynamicRenderingFeatures { <span class="keyword">true</span> },</div>
<div class="line">         },</div>
<div class="line">     } };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { gpu.allocator, vk::ImageCreateInfo {</div>
<div class="line">        {},</div>
<div class="line">        vk::ImageType::e2D,</div>
<div class="line">        vk::Format::eR8G8B8A8Unorm,</div>
<div class="line">        vk::Extent3D { 512, 512, 1 },</div>
<div class="line">        1, 1,</div>
<div class="line">        vk::SampleCountFlagBits::e1,</div>
<div class="line">        vk::ImageTiling::eOptimal,</div>
<div class="line">        vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eTransferSrc,</div>
<div class="line">    } };</div>
<div class="line">    <span class="keyword">const</span> vk::raii::ImageView imageView { gpu.device, image.getViewCreateInfo() };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> vk::raii::PipelineLayout pipelineLayout { gpu.device, vk::PipelineLayoutCreateInfo{} };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> vk::raii::Pipeline pipeline { gpu.device, <span class="keyword">nullptr</span>, vk::StructureChain {</div>
<div class="line">        vku::getDefaultGraphicsPipelineCreateInfo(</div>
<div class="line">            vku::createPipelineStages(</div>
<div class="line">                gpu.device,</div>
<div class="line">                <a class="code hl_function" href="structvku_1_1Shader.html#a5089098c11057b7ba4b6e9f0ecdb03bc">vku::Shader::fromSpirvFile</a>(COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.vert.spv&quot;</span>, vk::ShaderStageFlagBits::eVertex),</div>
<div class="line">                <a class="code hl_function" href="structvku_1_1Shader.html#a5089098c11057b7ba4b6e9f0ecdb03bc">vku::Shader::fromSpirvFile</a>(COMPILED_SHADER_DIR <span class="stringliteral">&quot;/triangle.frag.spv&quot;</span>, vk::ShaderStageFlagBits::eFragment)).get(),</div>
<div class="line">            *pipelineLayout, 1)</div>
<div class="line">            .setPRasterizationState(vku::unsafeAddress(vk::PipelineRasterizationStateCreateInfo {</div>
<div class="line">                {},</div>
<div class="line">                <span class="keyword">false</span>, <span class="keyword">false</span>,</div>
<div class="line">                vk::PolygonMode::eFill,</div>
<div class="line">                vk::CullModeFlagBits::eNone, {},</div>
<div class="line">                {}, {}, {}, {},</div>
<div class="line">                1.f,</div>
<div class="line">            }))</div>
<div class="line">            .setPViewportState(vku::unsafeAddress(vk::PipelineViewportStateCreateInfo {</div>
<div class="line">                {},</div>
<div class="line">                vku::unsafeProxy(vku::toViewport(vku::toExtent2D(image.extent))),</div>
<div class="line">                vku::unsafeProxy(vk::Rect2D { { 0, 0 }, vku::toExtent2D(image.extent) }),</div>
<div class="line">            }))</div>
<div class="line">            .setPDynamicState(vku::unsafeAddress(vk::PipelineDynamicStateCreateInfo{})),</div>
<div class="line">        vk::PipelineRenderingCreateInfo {</div>
<div class="line">            {},</div>
<div class="line">            image.format,</div>
<div class="line">        },</div>
<div class="line">    }.get() };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="classvku_1_1MappedBuffer.html">vku::MappedBuffer</a> destagingBuffer { gpu.allocator, vk::BufferCreateInfo {</div>
<div class="line">        {},</div>
<div class="line">        blockSize(image.format) * image.extent.width * image.extent.height,</div>
<div class="line">        vk::BufferUsageFlagBits::eTransferDst,</div>
<div class="line">    }, vku::allocation::hostRead };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> vk::raii::CommandPool graphicsCommandPool { gpu.device, vk::CommandPoolCreateInfo { {}, gpu.queueFamilies.graphics } };</div>
<div class="line">    vku::executeSingleCommand(*gpu.device, *graphicsCommandPool, gpu.queues.graphics, [&amp;](vk::CommandBuffer cb) {</div>
<div class="line">        cb.pipelineBarrier(</div>
<div class="line">            vk::PipelineStageFlagBits::eTopOfPipe, vk::PipelineStageFlagBits::eColorAttachmentOutput,</div>
<div class="line">            {}, {}, {},</div>
<div class="line">            vk::ImageMemoryBarrier {</div>
<div class="line">                {}, vk::AccessFlagBits::eColorAttachmentWrite,</div>
<div class="line">                {}, vk::ImageLayout::eColorAttachmentOptimal,</div>
<div class="line">                vk::QueueFamilyIgnored, vk::QueueFamilyIgnored,</div>
<div class="line">                image, vku::fullSubresourceRange(),</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">        cb.beginRenderingKHR({</div>
<div class="line">            {},</div>
<div class="line">            { { 0, 0 }, vku::toExtent2D(image.extent) },</div>
<div class="line">            1,</div>
<div class="line">            0,</div>
<div class="line">            vku::unsafeProxy(vk::RenderingAttachmentInfo {</div>
<div class="line">                *imageView, vk::ImageLayout::eColorAttachmentOptimal,</div>
<div class="line">                {}, {}, {},</div>
<div class="line">                vk::AttachmentLoadOp::eClear, vk::AttachmentStoreOp::eStore, vk::ClearColorValue { 0.f, 0.f, 0.f, 0.f },</div>
<div class="line">            }),</div>
<div class="line">        }, *gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">        cb.bindPipeline(vk::PipelineBindPoint::eGraphics, *pipeline);</div>
<div class="line">        cb.draw(3, 1, 0, 0);</div>
<div class="line"> </div>
<div class="line">        cb.endRenderingKHR(*gpu.device.getDispatcher());</div>
<div class="line"> </div>
<div class="line">        cb.pipelineBarrier(</div>
<div class="line">            vk::PipelineStageFlagBits::eColorAttachmentOutput, vk::PipelineStageFlagBits::eTransfer,</div>
<div class="line">            {}, {}, {},</div>
<div class="line">            vk::ImageMemoryBarrier {</div>
<div class="line">                vk::AccessFlagBits::eColorAttachmentWrite, vk::AccessFlagBits::eTransferRead,</div>
<div class="line">                vk::ImageLayout::eColorAttachmentOptimal, vk::ImageLayout::eTransferSrcOptimal,</div>
<div class="line">                vk::QueueFamilyIgnored, vk::QueueFamilyIgnored,</div>
<div class="line">                image, vku::fullSubresourceRange(),</div>
<div class="line">            });</div>
<div class="line"> </div>
<div class="line">        cb.copyImageToBuffer(</div>
<div class="line">            image, vk::ImageLayout::eTransferSrcOptimal,</div>
<div class="line">            destagingBuffer,</div>
<div class="line">            vk::BufferImageCopy {</div>
<div class="line">                0, 0, 0,</div>
<div class="line">                { vk::ImageAspectFlagBits::eColor, 0, 0, 1 },</div>
<div class="line">                vk::Offset3D{}, image.extent,</div>
<div class="line">            });</div>
<div class="line">    });</div>
<div class="line">    gpu.queues.graphics.waitIdle();</div>
<div class="line"> </div>
<div class="line">    stbi_write_png(<span class="stringliteral">&quot;output.png&quot;</span>, image.extent.width, image.extent.height, 4, destagingBuffer.data, blockSize(image.format) * image.extent.width);</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>impl.cpp</code> </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#define STB_IMAGE_WRITE_IMPLEMENTATION</span></div>
<div class="line"><span class="preprocessor">#include &lt;stb_image_write.h&gt;</span></div>
</div><!-- fragment --> </details>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

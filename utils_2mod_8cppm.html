<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vku: interface/utils/mod.cppm File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vku<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A set of Vulkan utilities based on RAII idiom and Modern C++ features.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b31d54d5631803016a26f28213a41162.html">interface</a></li><li class="navelem"><a class="el" href="dir_f3ace15706b110c27a8eff55aea52391.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mod.cppm File Reference<div class="ingroups">module <a class="el" href="module__vku.html">vku</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;vulkan/vulkan_hpp_macros.hpp&gt;</code><br />
<code>import vulkan_hpp;</code><br />
<code>import std;</code><br />
<code>import <a class="el" href="mod_8cppm.html">vku:utils.RefHolder</a>;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8bd3eacc2889e4012d3c861e275436ad" id="r_a8bd3eacc2889e4012d3c861e275436ad"><td class="memItemLeft" align="right" valign="top"><a id="a8bd3eacc2889e4012d3c861e275436ad" name="a8bd3eacc2889e4012d3c861e275436ad"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NOEXCEPT_IF_RELEASE</b></td></tr>
<tr class="separator:a8bd3eacc2889e4012d3c861e275436ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfff7147f0fdff4642a6667a375ae29" id="r_a8dfff7147f0fdff4642a6667a375ae29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dfff7147f0fdff4642a6667a375ae29">FWD</a>(...)</td></tr>
<tr class="separator:a8dfff7147f0fdff4642a6667a375ae29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a933ea645ad8992925f5f20f7d13fcdb9" id="r_a933ea645ad8992925f5f20f7d13fcdb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a933ea645ad8992925f5f20f7d13fcdb9"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a933ea645ad8992925f5f20f7d13fcdb9">vku::unsafeAddress</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:a933ea645ad8992925f5f20f7d13fcdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a temporary value and return its address.  <br /></td></tr>
<tr class="separator:a933ea645ad8992925f5f20f7d13fcdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae912235590cb30ea98ecd0563438db82" id="r_ae912235590cb30ea98ecd0563438db82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae912235590cb30ea98ecd0563438db82"><td class="memTemplItemLeft" align="right" valign="top">vk::ArrayProxyNoTemporaries&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae912235590cb30ea98ecd0563438db82">vku::unsafeProxy</a> (const T &amp;value) noexcept</td></tr>
<tr class="memdesc:ae912235590cb30ea98ecd0563438db82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a temporary value and return <code>vk::ArrayProxyNoTemporaries</code> of it.  <br /></td></tr>
<tr class="separator:ae912235590cb30ea98ecd0563438db82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce17e6bb7037de7b704fd02a29e7142" id="r_a6ce17e6bb7037de7b704fd02a29e7142"><td class="memTemplParams" colspan="2">template&lt;std::ranges::contiguous_range R&gt; </td></tr>
<tr class="memitem:a6ce17e6bb7037de7b704fd02a29e7142"><td class="memTemplItemLeft" align="right" valign="top">vk::ArrayProxyNoTemporaries&lt; const std::ranges::range_value_t&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ce17e6bb7037de7b704fd02a29e7142">vku::unsafeProxy</a> (const R &amp;range) noexcept</td></tr>
<tr class="memdesc:a6ce17e6bb7037de7b704fd02a29e7142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a temporary contiguous range and return <code>vk::ArrayProxyNoTemporaries</code> of it.  <br /></td></tr>
<tr class="separator:a6ce17e6bb7037de7b704fd02a29e7142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571b2bc0dd5aceb1fd7959e6b7e8f6b8" id="r_a571b2bc0dd5aceb1fd7959e6b7e8f6b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a571b2bc0dd5aceb1fd7959e6b7e8f6b8"><td class="memTemplItemLeft" align="right" valign="top">vk::ArrayProxyNoTemporaries&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a571b2bc0dd5aceb1fd7959e6b7e8f6b8">vku::unsafeProxy</a> (const std::initializer_list&lt; T &gt; &amp;list) noexcept</td></tr>
<tr class="memdesc:a571b2bc0dd5aceb1fd7959e6b7e8f6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a temporary initializer list and return <code>vk::ArrayProxyNoTemporaries</code> of it.  <br /></td></tr>
<tr class="separator:a571b2bc0dd5aceb1fd7959e6b7e8f6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd826b7006c0e4ad3aa6793dc155748c" id="r_acd826b7006c0e4ad3aa6793dc155748c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd826b7006c0e4ad3aa6793dc155748c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd826b7006c0e4ad3aa6793dc155748c">vku::contains</a> (vk::Flags&lt; T &gt; flags, T flag) noexcept</td></tr>
<tr class="memdesc:acd826b7006c0e4ad3aa6793dc155748c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <code>flag</code> is contained in <code>flags</code>.  <br /></td></tr>
<tr class="separator:acd826b7006c0e4ad3aa6793dc155748c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f0a9e8b7507d911e478e36cee4712b" id="r_ab4f0a9e8b7507d911e478e36cee4712b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f0a9e8b7507d911e478e36cee4712b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4f0a9e8b7507d911e478e36cee4712b">vku::contains</a> (vk::Flags&lt; T &gt; super, vk::Flags&lt; T &gt; sub) noexcept</td></tr>
<tr class="memdesc:ab4f0a9e8b7507d911e478e36cee4712b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether <code>sub</code> is contained in <code>super</code>.  <br /></td></tr>
<tr class="separator:ab4f0a9e8b7507d911e478e36cee4712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a690f245f267aa45068bf34b848b11" id="r_af5a690f245f267aa45068bf34b848b11"><td class="memItemLeft" align="right" valign="top">constexpr vk::Extent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a690f245f267aa45068bf34b848b11">vku::toExtent2D</a> (const vk::Extent3D &amp;extent) noexcept</td></tr>
<tr class="memdesc:af5a690f245f267aa45068bf34b848b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>vk::Extent3D</code> to <code>vk::Extent2D</code>.  <br /></td></tr>
<tr class="separator:af5a690f245f267aa45068bf34b848b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab001c5feb202c4af70a726be14399094" id="r_ab001c5feb202c4af70a726be14399094"><td class="memItemLeft" align="right" valign="top">constexpr vk::Extent2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab001c5feb202c4af70a726be14399094">vku::toExtent2D</a> (const vk::Offset2D &amp;offset) noexcept</td></tr>
<tr class="memdesc:ab001c5feb202c4af70a726be14399094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>vk::Offset2D</code> to <code>vk::Extent2D</code>.  <br /></td></tr>
<tr class="separator:ab001c5feb202c4af70a726be14399094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ee19a144f8b949b075c62298a5a6b6" id="r_ad3ee19a144f8b949b075c62298a5a6b6"><td class="memItemLeft" align="right" valign="top">constexpr vk::Offset2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ee19a144f8b949b075c62298a5a6b6">vku::toOffset2D</a> (const vk::Offset3D &amp;offset) noexcept</td></tr>
<tr class="memdesc:ad3ee19a144f8b949b075c62298a5a6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>vk::Offset3D</code> to <code>vk::Offset2D</code>.  <br /></td></tr>
<tr class="separator:ad3ee19a144f8b949b075c62298a5a6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a49eeca9c359188486f42f856f94ede" id="r_a9a49eeca9c359188486f42f856f94ede"><td class="memItemLeft" align="right" valign="top">constexpr vk::Offset2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a49eeca9c359188486f42f856f94ede">vku::toOffset2D</a> (const vk::Extent2D &amp;extent) noexcept</td></tr>
<tr class="memdesc:a9a49eeca9c359188486f42f856f94ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>vk::Extent2D</code> to <code>vk::Offset2D</code>.  <br /></td></tr>
<tr class="separator:a9a49eeca9c359188486f42f856f94ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e841ddac56506300072b6e3aeaedf6" id="r_a29e841ddac56506300072b6e3aeaedf6"><td class="memItemLeft" align="right" valign="top">constexpr vk::Viewport&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29e841ddac56506300072b6e3aeaedf6">vku::toViewport</a> (const vk::Extent2D &amp;extent, bool negativeHeight=false) noexcept</td></tr>
<tr class="memdesc:a29e841ddac56506300072b6e3aeaedf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <code>vk::Extent2D</code> to <code>vk::Viewport</code>, with depth=0..1.  <br /></td></tr>
<tr class="separator:a29e841ddac56506300072b6e3aeaedf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe350c3f8378d6cb61ef2cf5cee4d784" id="r_afe350c3f8378d6cb61ef2cf5cee4d784"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe350c3f8378d6cb61ef2cf5cee4d784"><td class="memTemplItemLeft" align="right" valign="top">T::CType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe350c3f8378d6cb61ef2cf5cee4d784">vku::toCType</a> (T handle) noexcept</td></tr>
<tr class="memdesc:afe350c3f8378d6cb61ef2cf5cee4d784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the Vulkan object handle into its corresponding C handle.  <br /></td></tr>
<tr class="separator:afe350c3f8378d6cb61ef2cf5cee4d784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dc5360f50bc011a987a96d1d1b528a" id="r_a85dc5360f50bc011a987a96d1d1b528a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85dc5360f50bc011a987a96d1d1b528a"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a85dc5360f50bc011a987a96d1d1b528a">vku::toUint64</a> (T handle) noexcept</td></tr>
<tr class="memdesc:a85dc5360f50bc011a987a96d1d1b528a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 64-bit GPU address of the Vulkan object.  <br /></td></tr>
<tr class="separator:a85dc5360f50bc011a987a96d1d1b528a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c9e156362594605590a38ece7b9d46" id="r_a50c9e156362594605590a38ece7b9d46"><td class="memTemplParams" colspan="2">template&lt;std::floating_point T = float&gt; </td></tr>
<tr class="memitem:a50c9e156362594605590a38ece7b9d46"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50c9e156362594605590a38ece7b9d46">vku::aspect</a> (const vk::Extent2D &amp;extent) noexcept</td></tr>
<tr class="memdesc:a50c9e156362594605590a38ece7b9d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get aspect ratio (width / height) of the 2-dimensional extent.  <br /></td></tr>
<tr class="separator:a50c9e156362594605590a38ece7b9d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8dfff7147f0fdff4642a6667a375ae29" name="a8dfff7147f0fdff4642a6667a375ae29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfff7147f0fdff4642a6667a375ae29">&#9670;&#160;</a></span>FWD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FWD</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static_cast&lt;</span>decltype(__VA_ARGS__) &amp;&amp;<span class="keyword">&gt;</span>(__VA_ARGS__)</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a50c9e156362594605590a38ece7b9d46" name="a50c9e156362594605590a38ece7b9d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c9e156362594605590a38ece7b9d46">&#9670;&#160;</a></span>aspect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::floating_point T = float&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T vku::aspect </td>
          <td>(</td>
          <td class="paramtype">const vk::Extent2D &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get aspect ratio (width / height) of the 2-dimensional extent. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Floating point type to calculate the aspect ratio. Default is <code>float</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>Extent to calculate the aspect ratio. Its height must not be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Aspect ratio of the extent. </dd></dl>

</div>
</div>
<a id="acd826b7006c0e4ad3aa6793dc155748c" name="acd826b7006c0e4ad3aa6793dc155748c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd826b7006c0e4ad3aa6793dc155748c">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vku::contains </td>
          <td>(</td>
          <td class="paramtype">vk::Flags&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether <code>flag</code> is contained in <code>flags</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Vulkan flags. </td></tr>
    <tr><td class="paramname">flag</td><td>Vulkan flag bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If flag is contained in flags, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>contains(vk::Flags&lt;T&gt;, vk::Flags&lt;T&gt;) -&gt; bool </dd></dl>

</div>
</div>
<a id="ab4f0a9e8b7507d911e478e36cee4712b" name="ab4f0a9e8b7507d911e478e36cee4712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f0a9e8b7507d911e478e36cee4712b">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vku::contains </td>
          <td>(</td>
          <td class="paramtype">vk::Flags&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>super</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::Flags&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em>sub</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether <code>sub</code> is contained in <code>super</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">super</td><td>Vulkan flags. </td></tr>
    <tr><td class="paramname">sub</td><td>Vulkan flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> If sub is contained in super, <code>false</code> otherwise. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>contains(vk::Flags&lt;T&gt;, T) -&gt; bool </dd></dl>

</div>
</div>
<a id="afe350c3f8378d6cb61ef2cf5cee4d784" name="afe350c3f8378d6cb61ef2cf5cee4d784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe350c3f8378d6cb61ef2cf5cee4d784">&#9670;&#160;</a></span>toCType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T::CType vku::toCType </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the Vulkan object handle into its corresponding C handle. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { device, vk::ImageCreateInfo { ... } };</div>
<div class="line">toCType&lt;vk::Image&gt;(image); <span class="comment">// VkImage struct. Image is first implicitly converted to vk::Image, and passed as the parameter.</span></div>
<div class="line">vk::raii::ImageView imageView { device, image.getViewCreateInfo { ... } };</div>
<div class="line">toCType(*imageView); <span class="comment">// VkImageView struct. Handle type is automatically inferred.</span></div>
<div class="ttc" id="astructvku_1_1AllocatedImage_html"><div class="ttname"><a href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a></div><div class="ttdoc">Owning image handle with memory allocation.</div><div class="ttdef"><b>Definition</b> AllocatedImage.cppm:33</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of Vulkan handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Vulkan object handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding inner C handle of <code>handle</code>. </dd></dl>

</div>
</div>
<a id="af5a690f245f267aa45068bf34b848b11" name="af5a690f245f267aa45068bf34b848b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a690f245f267aa45068bf34b848b11">&#9670;&#160;</a></span>toExtent2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Extent2D vku::toExtent2D </td>
          <td>(</td>
          <td class="paramtype">const vk::Extent3D &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <code>vk::Extent3D</code> to <code>vk::Extent2D</code>. </p>
<p>The depth component is discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>Extent to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted extent. </dd></dl>

</div>
</div>
<a id="ab001c5feb202c4af70a726be14399094" name="ab001c5feb202c4af70a726be14399094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab001c5feb202c4af70a726be14399094">&#9670;&#160;</a></span>toExtent2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Extent2D vku::toExtent2D </td>
          <td>(</td>
          <td class="paramtype">const vk::Offset2D &amp;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <code>vk::Offset2D</code> to <code>vk::Extent2D</code>. </p>
<p>Negative component is converted to the least unsigned integer congruent to the source integer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted extent. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Negative component will be cast to unsigned int, with C++ standard conversion rule. </dd></dl>

</div>
</div>
<a id="a9a49eeca9c359188486f42f856f94ede" name="a9a49eeca9c359188486f42f856f94ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a49eeca9c359188486f42f856f94ede">&#9670;&#160;</a></span>toOffset2D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Offset2D vku::toOffset2D </td>
          <td>(</td>
          <td class="paramtype">const vk::Extent2D &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <code>vk::Extent2D</code> to <code>vk::Offset2D</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>Extent to convert. Its width and height must be less than or equal to <code>2^31 - 1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted offset. </dd></dl>

</div>
</div>
<a id="ad3ee19a144f8b949b075c62298a5a6b6" name="ad3ee19a144f8b949b075c62298a5a6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ee19a144f8b949b075c62298a5a6b6">&#9670;&#160;</a></span>toOffset2D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Offset2D vku::toOffset2D </td>
          <td>(</td>
          <td class="paramtype">const vk::Offset3D &amp;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <code>vk::Offset3D</code> to <code>vk::Offset2D</code>. </p>
<p>The z component is discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted offset. </dd></dl>

</div>
</div>
<a id="a85dc5360f50bc011a987a96d1d1b528a" name="a85dc5360f50bc011a987a96d1d1b528a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dc5360f50bc011a987a96d1d1b528a">&#9670;&#160;</a></span>toUint64()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t vku::toUint64 </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 64-bit GPU address of the Vulkan object. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structvku_1_1AllocatedImage.html">vku::AllocatedImage</a> image { device, vk::ImageCreateInfo { ... } };</div>
<div class="line">toUint64&lt;vk::Image&gt;(image); <span class="comment">// Image is first implicitly converted to vk::Image, and passed as the parameter.</span></div>
<div class="line">vk::raii::ImageView imageView { device, image.getViewCreateInfo { ... } };</div>
<div class="line">toUint64(*imageView); <span class="comment">// Handle type is automatically inferred.</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of Vulkan handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Vulkan object handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 64-bit GPU address. </dd></dl>

</div>
</div>
<a id="a29e841ddac56506300072b6e3aeaedf6" name="a29e841ddac56506300072b6e3aeaedf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e841ddac56506300072b6e3aeaedf6">&#9670;&#160;</a></span>toViewport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Viewport vku::toViewport </td>
          <td>(</td>
          <td class="paramtype">const vk::Extent2D &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>negativeHeight</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">constexpr</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <code>vk::Extent2D</code> to <code>vk::Viewport</code>, with depth=0..1. </p>
<p>For example, setting viewport and scissor as full region of the swapchain for pipeline dynamic state would be: </p><div class="fragment"><div class="line">vk::Extent2D swapchainExtent = ...;</div>
<div class="line">cb.setViewport(0, vku::toViewport(swapchainExtent, <span class="keyword">true</span>)); <span class="comment">// Use negative viewport height.</span></div>
<div class="line">cb.setScissor(0, vk::Rect2D { { 0, 0 }, swapchainExtent });</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>Extent to convert. </td></tr>
    <tr><td class="paramname">negativeHeight</td><td>Whether the height is negative. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted viewport. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For about negative viewport height, see <a href="https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/">https://www.saschawillems.de/blog/2019/03/29/flipping-the-vulkan-viewport/</a> for detail. </dd></dl>

</div>
</div>
<a id="a933ea645ad8992925f5f20f7d13fcdb9" name="a933ea645ad8992925f5f20f7d13fcdb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933ea645ad8992925f5f20f7d13fcdb9">&#9670;&#160;</a></span>unsafeAddress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * vku::unsafeAddress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a temporary value and return its address. </p>
<p>In Vulkan-Hpp API, you can use this function to pass temporary values to functions that require a pointer. For example, the following code creating a Vulkan instance with an application info </p><div class="fragment"><div class="line">vk::raii::Instance instance { context, vk::InstanceCreateInfo {</div>
<div class="line">    {},</div>
<div class="line">    &amp;vk::ApplicationInfo { ... }, <span class="comment">// ERROR! Cannot take the address of a temporary value.</span></div>
<div class="line">} }; <span class="comment">// But vk::ApplicationInfo destroyed here.</span></div>
</div><!-- fragment --><p> is invalid, but you know that the <code>vk::ApplicationInfo</code> struct would remain its lifetime until the end of the expression. Although you can declare the struct before the instance creation line, it's quite verbose and you'll get tired for naming such trivial stuffs.</p>
<p>Instead, you can use this function to pass the temporary value to the function: </p><div class="fragment"><div class="line">vk::raii::Instance instance { context, vk::InstanceCreateInfo {</div>
<div class="line">    {},</div>
<div class="line">    vku::unsafeAddress(vk::ApplicationInfo { ... }),</div>
<div class="line">} }; <span class="comment">// vk::ApplicationInfo destroyed here, however vk::raii::Instance already created and it&#39;s fine.</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Temporary value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the temporary value. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The result address is only valid until the end of the expression, which contains the temporary value. </dd></dl>

</div>
</div>
<a id="a6ce17e6bb7037de7b704fd02a29e7142" name="a6ce17e6bb7037de7b704fd02a29e7142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce17e6bb7037de7b704fd02a29e7142">&#9670;&#160;</a></span>unsafeProxy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::contiguous_range R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::ArrayProxyNoTemporaries&lt; const std::ranges::range_value_t&lt; R &gt; &gt; vku::unsafeProxy </td>
          <td>(</td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a temporary contiguous range and return <code>vk::ArrayProxyNoTemporaries</code> of it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Temporary contiguous range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>vk::ArrayProxyNoTemporaries</code> of the temporary range. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The intention of this function follows the same reason as <code>unsafeAddress</code> function. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The result is only valid until the end of the expression, which contains the temporary range. </dd></dl>

</div>
</div>
<a id="a571b2bc0dd5aceb1fd7959e6b7e8f6b8" name="a571b2bc0dd5aceb1fd7959e6b7e8f6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571b2bc0dd5aceb1fd7959e6b7e8f6b8">&#9670;&#160;</a></span>unsafeProxy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::ArrayProxyNoTemporaries&lt; const T &gt; vku::unsafeProxy </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a temporary initializer list and return <code>vk::ArrayProxyNoTemporaries</code> of it. </p>
<div class="fragment"><div class="line">vk::raii::DescriptorSetLayout device { device, vk::DescriptorSetLayoutCreateInfo {</div>
<div class="line">    {},</div>
<div class="line">    <span class="comment">// { vk::DescriptorSetLayoutBinding { ... }, ... }, // ERROR! calling deleted constructor of vk::ArrayProxyNoTemporaries&lt;const vk::DescriptorSetLayoutBinding&gt;.</span></div>
<div class="line">    vku::unsafeProxy({</div>
<div class="line">        vk::DescriptorSetLayoutBinding { ... },</div>
<div class="line">        vk::DescriptorSetLayoutBinding { ... },</div>
<div class="line">        ...</div>
<div class="line">    }), <span class="comment">// OK. Just make ensure that vk::DescriptorSetLayoutBindings alive until the end of the descriptor set layout creation.</span></div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Temporary initializer list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>vk::ArrayProxyNoTemporaries</code> of the temporary initializer list. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The intention of this function follows the same reason as <code>unsafeAddress</code> function. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The result is only valid until the end of the expression, which contains the temporary initializer list. </dd></dl>

</div>
</div>
<a id="ae912235590cb30ea98ecd0563438db82" name="ae912235590cb30ea98ecd0563438db82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae912235590cb30ea98ecd0563438db82">&#9670;&#160;</a></span>unsafeProxy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::ArrayProxyNoTemporaries&lt; const T &gt; vku::unsafeProxy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">export</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take a temporary value and return <code>vk::ArrayProxyNoTemporaries</code> of it. </p>
<div class="fragment"><div class="line">vk::raii::Device device { physicalDevice, vk::DeviceCreateInfo {</div>
<div class="line">    {},</div>
<div class="line">    <span class="comment">// { vk::DeviceQueueCreateInfo { ... } }, // ERROR! calling deleted constructor of vk::ArrayProxyNoTemporaries&lt;const vk::DeviceQueueCreateInfo&gt;.</span></div>
<div class="line">    vku::unsafeProxy(vk::DeviceQueueCreateInfo { ... }), <span class="comment">// OK. Just make ensure that vk::DeviceQueueCreateInfo make alive until the end of the device creation.</span></div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Temporary value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>vk::ArrayProxyNoTemporaries</code> of the temporary value. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The intention of this function follows the same reason as <code>unsafeAddress</code> function. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The result is only valid until the end of the expression, which contains the temporary value. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vku: vku::MappedBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vku<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A set of Vulkan utilities based on RAII idiom and Modern C++ features.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>vku</b></li><li class="navelem"><a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classvku_1_1MappedBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">vku::MappedBuffer Class Reference<span class="mlabels"><span class="mlabel">export</span></span><div class="ingroups">module <a class="el" href="module__vku.html">vku</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Owning buffer handle with memory allocation and CPU-accessible mapped data.  
 <a href="#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for vku::MappedBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvku_1_1MappedBuffer.png" usemap="#vku::MappedBuffer_map" alt=""/>
  <map id="vku::MappedBuffer_map" name="vku::MappedBuffer_map">
<area href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation." alt="vku::AllocatedBuffer" shape="rect" coords="0,56,126,80"/>
<area href="structvku_1_1Buffer.html" title="Non-owning vk::Buffer handle with the additional information." alt="vku::Buffer" shape="rect" coords="0,0,126,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa8518cf18faffc792ec9fbd3ddc023bd" id="r_aa8518cf18faffc792ec9fbd3ddc023bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8518cf18faffc792ec9fbd3ddc023bd">MappedBuffer</a> (vma::Allocator allocator, const vk::BufferCreateInfo &amp;createInfo, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ vma::AllocationCreateFlagBits::eHostAccessSequentialWrite|vma::AllocationCreateFlagBits::eMapped, vma::MemoryUsage::eAuto, })</td></tr>
<tr class="memdesc:aa8518cf18faffc792ec9fbd3ddc023bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mapped buffer.  <br /></td></tr>
<tr class="separator:aa8518cf18faffc792ec9fbd3ddc023bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad341b2e0f42f359abf20b99ada5e2e8a" id="r_ad341b2e0f42f359abf20b99ada5e2e8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires (!std::same_as&lt;T, std::from_range_t&gt; &amp;&amp; std::is_trivially_copyable_v&lt;T&gt;)</td></tr>
<tr class="memitem:ad341b2e0f42f359abf20b99ada5e2e8a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad341b2e0f42f359abf20b99ada5e2e8a">MappedBuffer</a> (vma::Allocator allocator, const T &amp;value, vk::BufferUsageFlags usage, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ vma::AllocationCreateFlagBits::eHostAccessSequentialWrite|vma::AllocationCreateFlagBits::eMapped, vma::MemoryUsage::eAuto, })</td></tr>
<tr class="memdesc:ad341b2e0f42f359abf20b99ada5e2e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mapped buffer of the given <code>value</code> and exclusive sharing mode.  <br /></td></tr>
<tr class="separator:ad341b2e0f42f359abf20b99ada5e2e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bf93cf7b3aeeddad83ea6511655200" id="r_ad0bf93cf7b3aeeddad83ea6511655200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; <br />
requires (!std::same_as&lt;T, std::from_range_t&gt; &amp;&amp; std::is_trivially_copyable_v&lt;T&gt;)</td></tr>
<tr class="memitem:ad0bf93cf7b3aeeddad83ea6511655200"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad0bf93cf7b3aeeddad83ea6511655200">MappedBuffer</a> (vma::Allocator allocator, const T &amp;value, vk::BufferUsageFlags usage, vk::ArrayProxy&lt; const std::uint32_t &gt; queueFamilyIndices, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ vma::AllocationCreateFlagBits::eHostAccessSequentialWrite|vma::AllocationCreateFlagBits::eMapped, vma::MemoryUsage::eAuto, })</td></tr>
<tr class="memdesc:ad0bf93cf7b3aeeddad83ea6511655200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mapped buffer of the given <code>value</code> and concurrent sharing mode.  <br /></td></tr>
<tr class="separator:ad0bf93cf7b3aeeddad83ea6511655200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977bd4acc69ffbb13ed55671e4e34e71" id="r_a977bd4acc69ffbb13ed55671e4e34e71"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; <br />
requires (std::ranges::sized_range&lt;R&gt; &amp;&amp; std::is_trivially_copyable_v&lt;std::ranges::range_value_t&lt;R&gt;&gt;)</td></tr>
<tr class="memitem:a977bd4acc69ffbb13ed55671e4e34e71"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a977bd4acc69ffbb13ed55671e4e34e71">MappedBuffer</a> (vma::Allocator allocator, std::from_range_t, R &amp;&amp;r, vk::BufferUsageFlags usage, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ vma::AllocationCreateFlagBits::eHostAccessSequentialWrite|vma::AllocationCreateFlagBits::eMapped, vma::MemoryUsage::eAuto, })</td></tr>
<tr class="memdesc:a977bd4acc69ffbb13ed55671e4e34e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mapped buffer of the given range with exclusive sharing mode.  <br /></td></tr>
<tr class="separator:a977bd4acc69ffbb13ed55671e4e34e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf77019949f23ebcbe6ec7fafbafde" id="r_affdf77019949f23ebcbe6ec7fafbafde"><td class="memTemplParams" colspan="2">template&lt;std::ranges::input_range R&gt; <br />
requires (std::ranges::sized_range&lt;R&gt; &amp;&amp; std::is_trivially_copyable_v&lt;std::ranges::range_value_t&lt;R&gt;&gt;)</td></tr>
<tr class="memitem:affdf77019949f23ebcbe6ec7fafbafde"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#affdf77019949f23ebcbe6ec7fafbafde">MappedBuffer</a> (vma::Allocator allocator, std::from_range_t, R &amp;&amp;r, vk::BufferUsageFlags usage, vk::ArrayProxy&lt; const std::uint32_t &gt; queueFamilyIndices, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ vma::AllocationCreateFlagBits::eHostAccessSequentialWrite|vma::AllocationCreateFlagBits::eMapped, vma::MemoryUsage::eAuto, })</td></tr>
<tr class="memdesc:affdf77019949f23ebcbe6ec7fafbafde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create mapped buffer of the given range with concurrent sharing mode.  <br /></td></tr>
<tr class="separator:affdf77019949f23ebcbe6ec7fafbafde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d842a09dade00ae9c754bc56f3e147a" id="r_a5d842a09dade00ae9c754bc56f3e147a"><td class="memItemLeft" align="right" valign="top"><a id="a5d842a09dade00ae9c754bc56f3e147a" name="a5d842a09dade00ae9c754bc56f3e147a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MappedBuffer</b> (const <a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:a5d842a09dade00ae9c754bc56f3e147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa35ea4d0ff9fbe1c604b8750d6ba5135" id="r_aa35ea4d0ff9fbe1c604b8750d6ba5135"><td class="memItemLeft" align="right" valign="top"><a id="aa35ea4d0ff9fbe1c604b8750d6ba5135" name="aa35ea4d0ff9fbe1c604b8750d6ba5135"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MappedBuffer</b> (<a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="separator:aa35ea4d0ff9fbe1c604b8750d6ba5135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce435aea9e56fd7ab78f70e9f4e398c" id="r_a2ce435aea9e56fd7ab78f70e9f4e398c"><td class="memItemLeft" align="right" valign="top"><a id="a2ce435aea9e56fd7ab78f70e9f4e398c" name="a2ce435aea9e56fd7ab78f70e9f4e398c"></a>
<a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:a2ce435aea9e56fd7ab78f70e9f4e398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb9855ff064813d21beda4601739c98" id="r_a6bb9855ff064813d21beda4601739c98"><td class="memItemLeft" align="right" valign="top"><a id="a6bb9855ff064813d21beda4601739c98" name="a6bb9855ff064813d21beda4601739c98"></a>
<a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a6bb9855ff064813d21beda4601739c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56b1e3599f503698ab1c42a82102169" id="r_ad56b1e3599f503698ab1c42a82102169"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad56b1e3599f503698ab1c42a82102169"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad56b1e3599f503698ab1c42a82102169">asRange</a> (vk::DeviceSize byteOffset=0) const noexcept</td></tr>
<tr class="memdesc:ad56b1e3599f503698ab1c42a82102169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>std::span&lt;const T&gt;</code> from the mapped memory range.  <br /></td></tr>
<tr class="separator:ad56b1e3599f503698ab1c42a82102169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7c04ef529e37ed5f7e2f3a32451138" id="r_a7b7c04ef529e37ed5f7e2f3a32451138"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b7c04ef529e37ed5f7e2f3a32451138"><td class="memTemplItemLeft" align="right" valign="top">std::span&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7b7c04ef529e37ed5f7e2f3a32451138">asRange</a> (vk::DeviceSize byteOffset=0) noexcept</td></tr>
<tr class="memdesc:a7b7c04ef529e37ed5f7e2f3a32451138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>std::span&lt;T&gt;</code> from the mapped memory range.  <br /></td></tr>
<tr class="separator:a7b7c04ef529e37ed5f7e2f3a32451138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7a70227749dd5e1f7505a243ab30ec" id="r_aae7a70227749dd5e1f7505a243ab30ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae7a70227749dd5e1f7505a243ab30ec"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aae7a70227749dd5e1f7505a243ab30ec">asValue</a> (vk::DeviceSize byteOffset=0) const noexcept</td></tr>
<tr class="memdesc:aae7a70227749dd5e1f7505a243ab30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference of <code>T</code> from the mapped memory.  <br /></td></tr>
<tr class="separator:aae7a70227749dd5e1f7505a243ab30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754af0aba63cd9f6c7dc4939f722aec2" id="r_a754af0aba63cd9f6c7dc4939f722aec2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a754af0aba63cd9f6c7dc4939f722aec2"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a754af0aba63cd9f6c7dc4939f722aec2">asValue</a> (vk::DeviceSize byteOffset=0) noexcept</td></tr>
<tr class="memdesc:a754af0aba63cd9f6c7dc4939f722aec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get const reference of <code>T</code> from the mapped memory.  <br /></td></tr>
<tr class="separator:a754af0aba63cd9f6c7dc4939f722aec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8baacb7b451c2ee1a6a6c31d6da85e8" id="r_aa8baacb7b451c2ee1a6a6c31d6da85e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8baacb7b451c2ee1a6a6c31d6da85e8">unmap</a> () &amp;&amp;noexcept</td></tr>
<tr class="memdesc:aa8baacb7b451c2ee1a6a6c31d6da85e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap the allocation and slice this object to <code><a class="el" href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation.">AllocatedBuffer</a></code>.  <br /></td></tr>
<tr class="separator:aa8baacb7b451c2ee1a6a6c31d6da85e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structvku_1_1AllocatedBuffer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structvku_1_1AllocatedBuffer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structvku_1_1AllocatedBuffer.html">vku::AllocatedBuffer</a></td></tr>
<tr class="memitem:a90ab9cd1bb1fc6f1e97775500ac152b4 inherit pub_methods_structvku_1_1AllocatedBuffer" id="r_a90ab9cd1bb1fc6f1e97775500ac152b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvku_1_1AllocatedBuffer.html#a90ab9cd1bb1fc6f1e97775500ac152b4">AllocatedBuffer</a> (vma::Allocator allocator, const vk::BufferCreateInfo &amp;createInfo, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ {}, vma::MemoryUsage::eAutoPreferDevice })</td></tr>
<tr class="memdesc:a90ab9cd1bb1fc6f1e97775500ac152b4 inherit pub_methods_structvku_1_1AllocatedBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code>vk::Buffer</code>, allocate memory, then bind them.  <br /></td></tr>
<tr class="separator:a90ab9cd1bb1fc6f1e97775500ac152b4 inherit pub_methods_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620974a7f1829fbe46267c0b1df84619 inherit pub_methods_structvku_1_1AllocatedBuffer" id="r_a620974a7f1829fbe46267c0b1df84619"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>AllocatedBuffer</b> (const <a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:a620974a7f1829fbe46267c0b1df84619 inherit pub_methods_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75231721194e8f4acd302d947e949ed4 inherit pub_methods_structvku_1_1AllocatedBuffer" id="r_a75231721194e8f4acd302d947e949ed4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>AllocatedBuffer</b> (<a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a75231721194e8f4acd302d947e949ed4 inherit pub_methods_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04582a163aa8a3003c0273d9c5ce0fce inherit pub_methods_structvku_1_1AllocatedBuffer" id="r_a04582a163aa8a3003c0273d9c5ce0fce"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> &amp;)=delete</td></tr>
<tr class="separator:a04582a163aa8a3003c0273d9c5ce0fce inherit pub_methods_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08b5c07c2ba80c1e6be193202529c03 inherit pub_methods_structvku_1_1AllocatedBuffer" id="r_ac08b5c07c2ba80c1e6be193202529c03"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:ac08b5c07c2ba80c1e6be193202529c03 inherit pub_methods_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structvku_1_1Buffer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_structvku_1_1Buffer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structvku_1_1Buffer.html">vku::Buffer</a></td></tr>
<tr class="memitem:ac41fb756a79a6448805ed5e60768c0c6 inherit pub_methods_structvku_1_1Buffer" id="r_ac41fb756a79a6448805ed5e60768c0c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvku_1_1Buffer.html#ac41fb756a79a6448805ed5e60768c0c6">operator vk::Buffer</a> () const noexcept</td></tr>
<tr class="separator:ac41fb756a79a6448805ed5e60768c0c6 inherit pub_methods_structvku_1_1Buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad1f73c456179abf6bc46b1dbd79ba340" id="r_ad1f73c456179abf6bc46b1dbd79ba340"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1f73c456179abf6bc46b1dbd79ba340">data</a></td></tr>
<tr class="memdesc:ad1f73c456179abf6bc46b1dbd79ba340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start address of the mapped memory.  <br /></td></tr>
<tr class="separator:ad1f73c456179abf6bc46b1dbd79ba340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_structvku_1_1AllocatedBuffer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_structvku_1_1AllocatedBuffer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="structvku_1_1AllocatedBuffer.html">vku::AllocatedBuffer</a></td></tr>
<tr class="memitem:a556ba1cf445bcc277de8d06098b2016c inherit pub_attribs_structvku_1_1AllocatedBuffer" id="r_a556ba1cf445bcc277de8d06098b2016c"><td class="memItemLeft" align="right" valign="top">
vma::Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>allocator</b></td></tr>
<tr class="memdesc:a556ba1cf445bcc277de8d06098b2016c inherit pub_attribs_structvku_1_1AllocatedBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">VMA allocator used by the creation. <br /></td></tr>
<tr class="separator:a556ba1cf445bcc277de8d06098b2016c inherit pub_attribs_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5d590337a216455739b630692ede35 inherit pub_attribs_structvku_1_1AllocatedBuffer" id="r_a9a5d590337a216455739b630692ede35"><td class="memItemLeft" align="right" valign="top">
vma::Allocation&#160;</td><td class="memItemRight" valign="bottom"><b>allocation</b></td></tr>
<tr class="memdesc:a9a5d590337a216455739b630692ede35 inherit pub_attribs_structvku_1_1AllocatedBuffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation object. <br /></td></tr>
<tr class="separator:a9a5d590337a216455739b630692ede35 inherit pub_attribs_structvku_1_1AllocatedBuffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_structvku_1_1Buffer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_structvku_1_1Buffer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="structvku_1_1Buffer.html">vku::Buffer</a></td></tr>
<tr class="memitem:a802154bc3190bb6f422f7b6f83f682d6 inherit pub_attribs_structvku_1_1Buffer" id="r_a802154bc3190bb6f422f7b6f83f682d6"><td class="memItemLeft" align="right" valign="top">
vk::Buffer&#160;</td><td class="memItemRight" valign="bottom"><b>buffer</b></td></tr>
<tr class="memdesc:a802154bc3190bb6f422f7b6f83f682d6 inherit pub_attribs_structvku_1_1Buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan handle that represents the buffer. <br /></td></tr>
<tr class="separator:a802154bc3190bb6f422f7b6f83f682d6 inherit pub_attribs_structvku_1_1Buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d459a783e4bd037553e7a627900a33 inherit pub_attribs_structvku_1_1Buffer" id="r_a30d459a783e4bd037553e7a627900a33"><td class="memItemLeft" align="right" valign="top">
vk::DeviceSize&#160;</td><td class="memItemRight" valign="bottom"><b>size</b></td></tr>
<tr class="memdesc:a30d459a783e4bd037553e7a627900a33 inherit pub_attribs_structvku_1_1Buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvku_1_1Buffer.html" title="Non-owning vk::Buffer handle with the additional information.">Buffer</a> size in bytes. <br /></td></tr>
<tr class="separator:a30d459a783e4bd037553e7a627900a33 inherit pub_attribs_structvku_1_1Buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3454cd9635014866ba6ce001baece527" id="r_a3454cd9635014866ba6ce001baece527"><td class="memItemLeft" align="right" valign="top">std::variant&lt; <a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a>, <a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3454cd9635014866ba6ce001baece527">createStagingDstBuffer</a> (vma::Allocator allocator, const vk::BufferCreateInfo &amp;createInfo, const vma::AllocationCreateInfo &amp;allocationCreateInfo={ vma::AllocationCreateFlagBits::eHostAccessSequentialWrite|vma::AllocationCreateFlagBits::eHostAccessAllowTransferInstead|vma::AllocationCreateFlagBits::eMapped, vma::MemoryUsage::eAuto, })</td></tr>
<tr class="memdesc:a3454cd9635014866ba6ce001baece527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to create a staging destination buffer of both visible to host and device local.  <br /></td></tr>
<tr class="separator:a3454cd9635014866ba6ce001baece527"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Owning buffer handle with memory allocation and CPU-accessible mapped data. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa8518cf18faffc792ec9fbd3ddc023bd" name="aa8518cf18faffc792ec9fbd3ddc023bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8518cf18faffc792ec9fbd3ddc023bd">&#9670;&#160;</a></span>MappedBuffer() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vku::MappedBuffer::MappedBuffer </td>
          <td>(</td>
          <td class="paramtype">vma::Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vk::BufferCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>createInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vma::AllocationCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationCreateInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;vma::AllocationCreateFlagBits::eHostAccessSequentialWrite&#160;|&#160;vma::AllocationCreateFlagBits::eMapped,&#160;vma::MemoryUsage::eAuto,&#160;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create mapped buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>VMA allocator used to allocate memory. </td></tr>
    <tr><td class="paramname">createInfo</td><td><a class="el" href="structvku_1_1Buffer.html" title="Non-owning vk::Buffer handle with the additional information.">Buffer</a> create info. </td></tr>
    <tr><td class="paramname">allocationCreateInfo</td><td>Allocation create info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad341b2e0f42f359abf20b99ada5e2e8a" name="ad341b2e0f42f359abf20b99ada5e2e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad341b2e0f42f359abf20b99ada5e2e8a">&#9670;&#160;</a></span>MappedBuffer() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires (!std::same_as&lt;T, std::from_range_t&gt; &amp;&amp; std::is_trivially_copyable_v&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vku::MappedBuffer::MappedBuffer </td>
          <td>(</td>
          <td class="paramtype">vma::Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::BufferUsageFlags</td>          <td class="paramname"><span class="paramname"><em>usage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vma::AllocationCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationCreateInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;vma::AllocationCreateFlagBits::eHostAccessSequentialWrite&#160;|&#160;vma::AllocationCreateFlagBits::eMapped,&#160;vma::MemoryUsage::eAuto,&#160;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create mapped buffer of the given <code>value</code> and exclusive sharing mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value, must be trivially copyable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>VMA allocator used to allocate memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value that will be copied to the whole buffer. </td></tr>
    <tr><td class="paramname">usage</td><td><a class="el" href="structvku_1_1Buffer.html" title="Non-owning vk::Buffer handle with the additional information.">Buffer</a> usage flags. </td></tr>
    <tr><td class="paramname">allocationCreateInfo</td><td>Allocation create info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0bf93cf7b3aeeddad83ea6511655200" name="ad0bf93cf7b3aeeddad83ea6511655200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bf93cf7b3aeeddad83ea6511655200">&#9670;&#160;</a></span>MappedBuffer() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; <br />
requires (!std::same_as&lt;T, std::from_range_t&gt; &amp;&amp; std::is_trivially_copyable_v&lt;T&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vku::MappedBuffer::MappedBuffer </td>
          <td>(</td>
          <td class="paramtype">vma::Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::BufferUsageFlags</td>          <td class="paramname"><span class="paramname"><em>usage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::ArrayProxy&lt; const std::uint32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>queueFamilyIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vma::AllocationCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationCreateInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;vma::AllocationCreateFlagBits::eHostAccessSequentialWrite&#160;|&#160;vma::AllocationCreateFlagBits::eMapped,&#160;vma::MemoryUsage::eAuto,&#160;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create mapped buffer of the given <code>value</code> and concurrent sharing mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the value, must be trivially copyable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>VMA allocator used to allocate memory. </td></tr>
    <tr><td class="paramname">value</td><td>Value that will be copied to the whole buffer. </td></tr>
    <tr><td class="paramname">usage</td><td>Buffer usage flags. </td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>Queue family indices that would be used at the concurrent sharing of the resource. </td></tr>
    <tr><td class="paramname">allocationCreateInfo</td><td>Allocation create info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a977bd4acc69ffbb13ed55671e4e34e71" name="a977bd4acc69ffbb13ed55671e4e34e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977bd4acc69ffbb13ed55671e4e34e71">&#9670;&#160;</a></span>MappedBuffer() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; <br />
requires (std::ranges::sized_range&lt;R&gt; &amp;&amp; std::is_trivially_copyable_v&lt;std::ranges::range_value_t&lt;R&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vku::MappedBuffer::MappedBuffer </td>
          <td>(</td>
          <td class="paramtype">vma::Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::from_range_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::BufferUsageFlags</td>          <td class="paramname"><span class="paramname"><em>usage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vma::AllocationCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationCreateInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;vma::AllocationCreateFlagBits::eHostAccessSequentialWrite&#160;|&#160;vma::AllocationCreateFlagBits::eMapped,&#160;vma::MemoryUsage::eAuto,&#160;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create mapped buffer of the given range with exclusive sharing mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Range type. It must be sized and its element type must be trivially copyable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>VMA allocator used to allocate memory. </td></tr>
    <tr><td class="paramname">r</td><td>Range of the elements that will be copied to the buffer. </td></tr>
    <tr><td class="paramname">usage</td><td>Buffer usage flags. </td></tr>
    <tr><td class="paramname">allocationCreateInfo</td><td>Allocation create info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affdf77019949f23ebcbe6ec7fafbafde" name="affdf77019949f23ebcbe6ec7fafbafde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdf77019949f23ebcbe6ec7fafbafde">&#9670;&#160;</a></span>MappedBuffer() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::input_range R&gt; <br />
requires (std::ranges::sized_range&lt;R&gt; &amp;&amp; std::is_trivially_copyable_v&lt;std::ranges::range_value_t&lt;R&gt;&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vku::MappedBuffer::MappedBuffer </td>
          <td>(</td>
          <td class="paramtype">vma::Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::from_range_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::BufferUsageFlags</td>          <td class="paramname"><span class="paramname"><em>usage</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::ArrayProxy&lt; const std::uint32_t &gt;</td>          <td class="paramname"><span class="paramname"><em>queueFamilyIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vma::AllocationCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationCreateInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;vma::AllocationCreateFlagBits::eHostAccessSequentialWrite&#160;|&#160;vma::AllocationCreateFlagBits::eMapped,&#160;vma::MemoryUsage::eAuto,&#160;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create mapped buffer of the given range with concurrent sharing mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>Range type. It must be sized and its element type must be trivially copyable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>VMA allocator used to allocate memory. </td></tr>
    <tr><td class="paramname">r</td><td>Range of the elements that will be copied to the buffer. </td></tr>
    <tr><td class="paramname">usage</td><td>Buffer usage flags. </td></tr>
    <tr><td class="paramname">queueFamilyIndices</td><td>Queue family indices that would be used at the concurrent sharing of the resource. </td></tr>
    <tr><td class="paramname">allocationCreateInfo</td><td>Allocation create info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad56b1e3599f503698ab1c42a82102169" name="ad56b1e3599f503698ab1c42a82102169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56b1e3599f503698ab1c42a82102169">&#9670;&#160;</a></span>asRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; const T &gt; vku::MappedBuffer::asRange </td>
          <td>(</td>
          <td class="paramtype">vk::DeviceSize</td>          <td class="paramname"><span class="paramname"><em>byteOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <code>std::span&lt;const T&gt;</code> from the mapped memory range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteOffset</td><td>Beginning offset in bytes. The remaining size must be greater than or equal to <code>sizeof(T)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::span&lt;const T&gt;</code>, whose address starts from (mapped address) + <code>byteOffset</code>. </dd></dl>

</div>
</div>
<a id="a7b7c04ef529e37ed5f7e2f3a32451138" name="a7b7c04ef529e37ed5f7e2f3a32451138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7c04ef529e37ed5f7e2f3a32451138">&#9670;&#160;</a></span>asRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::span&lt; T &gt; vku::MappedBuffer::asRange </td>
          <td>(</td>
          <td class="paramtype">vk::DeviceSize</td>          <td class="paramname"><span class="paramname"><em>byteOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get <code>std::span&lt;T&gt;</code> from the mapped memory range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the elements in the span. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteOffset</td><td>Beginning offset in bytes. The remaining size must be greater than or equal to <code>sizeof(T)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::span&lt;T&gt;</code>, whose address starts from (mapped address) + <code>byteOffset</code>. </dd></dl>

</div>
</div>
<a id="aae7a70227749dd5e1f7505a243ab30ec" name="aae7a70227749dd5e1f7505a243ab30ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7a70227749dd5e1f7505a243ab30ec">&#9670;&#160;</a></span>asValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; vku::MappedBuffer::asValue </td>
          <td>(</td>
          <td class="paramtype">vk::DeviceSize</td>          <td class="paramname"><span class="paramname"><em>byteOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const reference of <code>T</code> from the mapped memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteOffset</td><td>Beginning offset in bytes. The remaining size must be greater than or equal to <code>sizeof(T)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference of <code>T</code>, whose address starts from (mapped address) + <code>byteOffset</code>. </dd></dl>

</div>
</div>
<a id="a754af0aba63cd9f6c7dc4939f722aec2" name="a754af0aba63cd9f6c7dc4939f722aec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754af0aba63cd9f6c7dc4939f722aec2">&#9670;&#160;</a></span>asValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; vku::MappedBuffer::asValue </td>
          <td>(</td>
          <td class="paramtype">vk::DeviceSize</td>          <td class="paramname"><span class="paramname"><em>byteOffset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get const reference of <code>T</code> from the mapped memory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteOffset</td><td>Beginning offset in bytes. The remaining size must be greater than or equal to <code>sizeof(T)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference of <code>T</code>, whose address starts from (mapped address) + <code>byteOffset</code>. </dd></dl>

</div>
</div>
<a id="aa8baacb7b451c2ee1a6a6c31d6da85e8" name="aa8baacb7b451c2ee1a6a6c31d6da85e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8baacb7b451c2ee1a6a6c31d6da85e8">&#9670;&#160;</a></span>unmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a> vku::MappedBuffer::unmap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">nodiscard</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmap the allocation and slice this object to <code><a class="el" href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation.">AllocatedBuffer</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Slice of this object. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a3454cd9635014866ba6ce001baece527" name="a3454cd9635014866ba6ce001baece527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3454cd9635014866ba6ce001baece527">&#9670;&#160;</a></span>createStagingDstBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; <a class="el" href="structvku_1_1AllocatedBuffer.html">AllocatedBuffer</a>, <a class="el" href="classvku_1_1MappedBuffer.html">MappedBuffer</a> &gt; createStagingDstBuffer </td>
          <td>(</td>
          <td class="paramtype">vma::Allocator</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vk::BufferCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>createInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vma::AllocationCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>allocationCreateInfo</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{&#160;vma::AllocationCreateFlagBits::eHostAccessSequentialWrite&#160;|&#160;vma::AllocationCreateFlagBits::eHostAccessAllowTransferInstead&#160;|&#160;vma::AllocationCreateFlagBits::eMapped,&#160;vma::MemoryUsage::eAuto,&#160;}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to create a staging destination buffer of both visible to host and device local. </p>
<p>In UMA architectures, you don't have to transfer the data from host visible buffer to device local buffer, since they are both likely to be in the same memory heap. This function provides a simple mechanism to create a buffer of this purpose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>VMA allocator used to allocate memory. </td></tr>
    <tr><td class="paramname">createInfo</td><td><a class="el" href="structvku_1_1Buffer.html" title="Non-owning vk::Buffer handle with the additional information.">Buffer</a> create info. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Variant of either <a class="el" href="structvku_1_1AllocatedBuffer.html" title="Owning buffer handle with memory allocation.">AllocatedBuffer</a> (non-UMA architecture) or <a class="el" href="classvku_1_1MappedBuffer.html" title="Owning buffer handle with memory allocation and CPU-accessible mapped data.">MappedBuffer</a> (UMA architecture). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad1f73c456179abf6bc46b1dbd79ba340" name="ad1f73c456179abf6bc46b1dbd79ba340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f73c456179abf6bc46b1dbd79ba340">&#9670;&#160;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vku::MappedBuffer::data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start address of the mapped memory. </p>
<p>This is only valid during the lifetime of this object. Destroying this object will unmap the memory. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>interface/buffers/<a class="el" href="MappedBuffer_8cppm.html">MappedBuffer.cppm</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
